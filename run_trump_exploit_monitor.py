#!/usr/bin/env python3
"""
TRUMP EXPLOIT MONITOR
=====================
Proactive Trump intelligence with Discord alerts.

We're not waiting for Trump - we're ANTICIPATING him.
"""

import os
import sys
import time
import logging
import traceback
from datetime import datetime, timedelta
from pathlib import Path

# Add paths
base_path = Path(__file__).parent
sys.path.insert(0, str(base_path))
sys.path.append(str(base_path / 'live_monitoring' / 'enrichment'))
sys.path.append(str(base_path / 'live_monitoring' / 'alerting'))

from trump_intelligence import TrumpIntelligenceEngine, TrumpEvent, MarketImpact

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class DiscordTrumpAlerter:
    """Send Trump alerts to Discord"""
    
    def __init__(self, webhook_url: str):
        self.webhook_url = webhook_url
        self.enabled = bool(webhook_url)
        
        if not self.enabled:
            logger.warning("Discord webhook not configured - alerts disabled")
    
    def send_trump_event(self, event: TrumpEvent):
        """Send Trump event to Discord"""
        if not self.enabled:
            return
        
        import requests
        
        # Color based on impact
        color_map = {
            MarketImpact.VERY_BEARISH: 0xFF0000,   # Red
            MarketImpact.BEARISH: 0xFF6600,        # Orange
            MarketImpact.NEUTRAL: 0x808080,         # Gray
            MarketImpact.BULLISH: 0x00FF00,         # Green
            MarketImpact.VERY_BULLISH: 0x00FF00,    # Bright Green
        }
        
        urgency_emoji = {
            "immediate": "üö®",
            "prepare": "‚ö°",
            "watch": "üëÄ"
        }
        
        embed = {
            "title": f"{urgency_emoji.get(event.urgency, 'üìä')} TRUMP SIGNAL: {event.catalyst_type.value.upper()}",
            "description": event.content[:300] + "..." if len(event.content) > 300 else event.content,
            "color": color_map.get(event.expected_impact, 0x808080),
            "fields": [
                {"name": "Impact", "value": event.expected_impact.value.upper(), "inline": True},
                {"name": "Confidence", "value": f"{event.confidence:.0%}", "inline": True},
                {"name": "Urgency", "value": event.urgency.upper(), "inline": True},
                {"name": "Keywords", "value": ", ".join(event.keywords_matched[:5]), "inline": False},
                {"name": "Affected Symbols", "value": ", ".join(event.affected_symbols[:6]), "inline": False},
                {"name": "Trade Recommendation", "value": event.trade_recommendation, "inline": False},
            ],
            "footer": {"text": "Trump Intelligence Engine"},
            "timestamp": datetime.now().isoformat()
        }
        
        payload = {
            "username": "Trump Signal Bot",
            "embeds": [embed]
        }
        
        try:
            response = requests.post(self.webhook_url, json=payload, timeout=10)
            response.raise_for_status()
            logger.info(f"‚úÖ Sent Trump alert to Discord: {event.catalyst_type.value}")
        except Exception as e:
            logger.error(f"Error sending to Discord: {e}")
    
    def send_briefing(self, briefing: str):
        """Send daily briefing to Discord"""
        if not self.enabled:
            return
        
        import requests
        
        # Split briefing into chunks if too long
        max_len = 1900
        chunks = [briefing[i:i+max_len] for i in range(0, len(briefing), max_len)]
        
        for i, chunk in enumerate(chunks):
            payload = {
                "username": "Trump Intelligence Bot",
                "content": f"```\n{chunk}\n```" if i == 0 else f"```\n{chunk}\n```"
            }
            
            try:
                requests.post(self.webhook_url, json=payload, timeout=10)
                time.sleep(0.5)  # Rate limiting
            except Exception as e:
                logger.error(f"Error sending briefing chunk: {e}")
    
    def send_scenario_alert(self, scenario_alert: str):
        """Send scenario preparation alert"""
        if not self.enabled:
            return
        
        import requests
        
        embed = {
            "title": "üéØ TRUMP SCENARIO ALERT",
            "description": scenario_alert[:2000],
            "color": 0xFFD700,  # Gold
            "footer": {"text": "Proactive Intelligence"},
            "timestamp": datetime.now().isoformat()
        }
        
        payload = {
            "username": "Trump Scenario Bot",
            "embeds": [embed]
        }
        
        try:
            requests.post(self.webhook_url, json=payload, timeout=10)
        except Exception as e:
            logger.error(f"Error sending scenario alert: {e}")


class TrumpExploitMonitor:
    """
    Continuous Trump monitoring for market exploitation
    """
    
    def __init__(self):
        self.intelligence = TrumpIntelligenceEngine(
            perplexity_api_key=os.getenv('PERPLEXITY_API_KEY')
        )
        self.discord = DiscordTrumpAlerter(
            webhook_url=os.getenv('DISCORD_WEBHOOK_URL')
        )
        
        # Tracking
        self.last_check = None
        self.last_briefing = None
        self.seen_events = set()  # Track seen events to avoid duplicates
        
        # Settings
        self.check_interval = 300  # 5 minutes
        self.briefing_hours = [6, 12, 18]  # Briefing times (ET)
    
    def should_send_briefing(self) -> bool:
        """Check if it's time for a briefing"""
        now = datetime.now()
        current_hour = now.hour
        
        if current_hour in self.briefing_hours:
            if self.last_briefing is None or self.last_briefing.date() < now.date():
                return True
            if self.last_briefing.hour != current_hour:
                return True
        return False
    
    def check_and_alert(self):
        """Check for Trump signals and send alerts"""
        logger.info("üîç Checking for Trump signals...")
        
        try:
            # Fetch news
            news = self.intelligence.fetch_trump_news(hours=2)
            
            if not news:
                logger.info("   No news fetched")
                return
            
            # Analyze for signals
            events = self.intelligence.analyze_for_trump_signals(news)
            
            # Filter for new, high-confidence events
            new_events = []
            for event in events:
                event_key = f"{event.catalyst_type.value}_{hash(event.content[:100])}"
                if event_key not in self.seen_events and event.confidence >= 0.4:
                    new_events.append(event)
                    self.seen_events.add(event_key)
            
            # Limit seen events memory
            if len(self.seen_events) > 1000:
                self.seen_events = set(list(self.seen_events)[-500:])
            
            # Alert on significant events
            for event in new_events:
                if event.urgency == "immediate" or event.expected_impact in [MarketImpact.VERY_BEARISH, MarketImpact.VERY_BULLISH]:
                    logger.info(f"üö® IMMEDIATE ALERT: {event.catalyst_type.value}")
                    self.discord.send_trump_event(event)
                elif event.urgency == "prepare":
                    logger.info(f"‚ö° PREPARE ALERT: {event.catalyst_type.value}")
                    self.discord.send_trump_event(event)
                else:
                    logger.info(f"üëÄ WATCHING: {event.catalyst_type.value} ({event.confidence:.0%})")
            
            logger.info(f"   Found {len(events)} events, {len(new_events)} new")
            
        except Exception as e:
            logger.error(f"Error checking Trump signals: {e}")
            logger.debug(traceback.format_exc())
    
    def send_daily_briefing(self):
        """Send comprehensive briefing"""
        logger.info("üìã Generating Trump briefing...")
        
        try:
            briefing = self.intelligence.generate_trump_briefing()
            self.discord.send_briefing(briefing)
            self.last_briefing = datetime.now()
            logger.info("‚úÖ Briefing sent to Discord")
        except Exception as e:
            logger.error(f"Error sending briefing: {e}")
    
    def send_proactive_scenarios(self):
        """Send proactive scenario alerts"""
        alerts = self.intelligence.get_proactive_alerts()
        
        for alert in alerts[:2]:  # Max 2 scenarios per check
            self.discord.send_scenario_alert(alert)
    
    def run(self):
        """Run continuous monitoring"""
        logger.info("=" * 60)
        logger.info("üéØ TRUMP EXPLOIT MONITOR STARTING")
        logger.info("=" * 60)
        logger.info(f"   Perplexity API: {'‚úÖ' if self.intelligence.perplexity_key else '‚ùå'}")
        logger.info(f"   Discord: {'‚úÖ' if self.discord.enabled else '‚ùå'}")
        logger.info(f"   Check interval: {self.check_interval}s")
        logger.info("=" * 60)
        
        # Initial briefing
        self.send_daily_briefing()
        
        while True:
            try:
                now = datetime.now()
                
                # Regular check
                self.check_and_alert()
                self.last_check = now
                
                # Periodic briefing
                if self.should_send_briefing():
                    self.send_daily_briefing()
                
                # Wait before next check
                logger.info(f"üí§ Sleeping {self.check_interval}s until next check...")
                time.sleep(self.check_interval)
                
            except KeyboardInterrupt:
                logger.info("\n‚ö†Ô∏è Shutting down Trump monitor...")
                break
            except Exception as e:
                logger.error(f"Error in main loop: {e}")
                logger.debug(traceback.format_exc())
                time.sleep(60)  # Wait before retry


def quick_check():
    """Quick one-time check (no continuous loop)"""
    logging.basicConfig(level=logging.INFO, format='%(message)s')
    
    print("=" * 60)
    print("üéØ TRUMP INTELLIGENCE - QUICK CHECK")
    print("=" * 60)
    
    engine = TrumpIntelligenceEngine()
    
    # Generate and print briefing
    briefing = engine.generate_trump_briefing()
    print(briefing)
    
    # Send to Discord if configured
    webhook = os.getenv('DISCORD_WEBHOOK_URL')
    if webhook:
        alerter = DiscordTrumpAlerter(webhook)
        alerter.send_briefing(briefing)
        print("\n‚úÖ Briefing sent to Discord!")


def main():
    """Main entry point"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Trump Exploit Monitor")
    parser.add_argument("--quick", action="store_true", help="Quick one-time check")
    parser.add_argument("--interval", type=int, default=300, help="Check interval in seconds")
    args = parser.parse_args()
    
    if args.quick:
        quick_check()
    else:
        monitor = TrumpExploitMonitor()
        monitor.check_interval = args.interval
        monitor.run()


if __name__ == "__main__":
    main()




