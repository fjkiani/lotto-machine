"""
Economic Data â†’ Fed Watch â†’ Market Exploit Engine ðŸ”¥

Strategy: Exploit economic releases by predicting Fed Watch probability shifts.

Flow:
1. Load economic calendar â†’ Know what's coming
2. Track consensus expectations â†’ What market expects
3. On release: Compare actual vs forecast (surprise)
4. Predict Fed Watch shift â†’ Historical patterns
5. Generate trade signal â†’ Position accordingly

Key Events:
- NFP (Jobs) - Weak = More cuts = Bullish for stocks
- CPI (Inflation) - Hot = Fewer cuts = Bearish
- Unemployment - High = More cuts = Bullish
- PCE - Fed's preferred metric = Very important
- Retail Sales - Weak = More cuts = Bullish
- GDP - Weak = More cuts = Bullish
"""

import os
import sys
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from typing import List, Dict, Optional
from enum import Enum
import logging

# Add parent paths
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

logger = logging.getLogger(__name__)


class EventImpactDirection(Enum):
    """How economic data affects Fed policy."""
    HAWKISH = "hawkish"   # Strong data = fewer cuts
    DOVISH = "dovish"     # Weak data = more cuts
    MIXED = "mixed"


@dataclass
class EconomicEvent:
    """Structured economic event with Fed impact analysis."""
    name: str
    time: str
    actual: Optional[str]
    forecast: Optional[str]
    previous: Optional[str]
    impact: str  # high/medium/low
    surprise_sigma: Optional[float]
    
    # Fed impact analysis
    fed_impact_type: EventImpactDirection = EventImpactDirection.MIXED
    expected_fed_watch_shift: float = 0.0  # Expected change in cut probability
    confidence: float = 0.0
    trade_signal: str = ""
    trade_rationale: str = ""


@dataclass
class EconomicExploitSignal:
    """Trading signal based on economic data."""
    timestamp: datetime
    event_name: str
    signal_type: str  # "PRE_RELEASE" or "POST_RELEASE"
    
    action: str  # "BUY" or "SELL"
    symbols: List[str]
    
    # Fed Watch prediction
    current_cut_prob: float
    predicted_cut_prob: float
    predicted_shift: float
    
    # Trade details
    confidence: float
    rationale: str
    
    # Risk management
    entry_timing: str  # "IMMEDIATE", "WAIT_5MIN", "WAIT_CONFIRMATION"
    stop_loss_pct: float = 1.0
    take_profit_pct: float = 2.0


# ========================================================================================
# ECONOMIC EVENT â†’ FED WATCH IMPACT MAPPING
# ========================================================================================

# How each economic indicator affects Fed policy expectations
EVENT_FED_IMPACT = {
    # JOBS DATA - Weak jobs = more cuts
    "nonfarm payrolls": {
        "type": "employment",
        "weak_impact": "dovish",  # Weak = more cuts
        "strong_impact": "hawkish",  # Strong = fewer cuts
        "typical_shift": 5.0,  # Typical Fed Watch shift %
        "market_reaction": {
            "dovish": {"action": "BUY", "symbols": ["SPY", "QQQ", "TLT"]},
            "hawkish": {"action": "SELL", "symbols": ["SPY", "QQQ"]},
        }
    },
    "unemployment rate": {
        "type": "employment",
        "weak_impact": "dovish",  # High unemployment = more cuts (this is inverse)
        "strong_impact": "hawkish",  # Low unemployment = fewer cuts
        "typical_shift": 3.0,
        "market_reaction": {
            "dovish": {"action": "BUY", "symbols": ["SPY", "QQQ", "TLT"]},
            "hawkish": {"action": "SELL", "symbols": ["SPY", "QQQ"]},
        }
    },
    "initial jobless claims": {
        "type": "employment",
        "weak_impact": "dovish",  # High claims = weak labor = more cuts
        "strong_impact": "hawkish",
        "typical_shift": 2.0,
        "market_reaction": {
            "dovish": {"action": "BUY", "symbols": ["SPY", "TLT"]},
            "hawkish": {"action": "SELL", "symbols": ["TLT"]},
        }
    },
    
    # INFLATION DATA - Hot inflation = fewer cuts
    "cpi": {
        "type": "inflation",
        "weak_impact": "dovish",  # Low inflation = more cuts
        "strong_impact": "hawkish",  # High inflation = fewer cuts
        "typical_shift": 5.0,
        "market_reaction": {
            "dovish": {"action": "BUY", "symbols": ["SPY", "QQQ", "TLT"]},
            "hawkish": {"action": "SELL", "symbols": ["SPY", "QQQ", "TLT"]},
        }
    },
    "core cpi": {
        "type": "inflation",
        "weak_impact": "dovish",
        "strong_impact": "hawkish",
        "typical_shift": 4.0,
        "market_reaction": {
            "dovish": {"action": "BUY", "symbols": ["SPY", "QQQ", "TLT"]},
            "hawkish": {"action": "SELL", "symbols": ["SPY", "QQQ", "TLT"]},
        }
    },
    "ppi": {
        "type": "inflation",
        "weak_impact": "dovish",
        "strong_impact": "hawkish",
        "typical_shift": 3.0,
        "market_reaction": {
            "dovish": {"action": "BUY", "symbols": ["SPY", "TLT"]},
            "hawkish": {"action": "SELL", "symbols": ["TLT"]},
        }
    },
    "pce": {
        "type": "inflation",
        "weak_impact": "dovish",
        "strong_impact": "hawkish",
        "typical_shift": 6.0,  # PCE is Fed's preferred - moves more
        "market_reaction": {
            "dovish": {"action": "BUY", "symbols": ["SPY", "QQQ", "TLT"]},
            "hawkish": {"action": "SELL", "symbols": ["SPY", "QQQ", "TLT"]},
        }
    },
    "core pce": {
        "type": "inflation",
        "weak_impact": "dovish",
        "strong_impact": "hawkish",
        "typical_shift": 7.0,  # Core PCE is THE metric
        "market_reaction": {
            "dovish": {"action": "BUY", "symbols": ["SPY", "QQQ", "TLT"]},
            "hawkish": {"action": "SELL", "symbols": ["SPY", "QQQ", "TLT"]},
        }
    },
    
    # GROWTH DATA - Weak growth = more cuts
    "gdp": {
        "type": "growth",
        "weak_impact": "dovish",
        "strong_impact": "hawkish",
        "typical_shift": 4.0,
        "market_reaction": {
            "dovish": {"action": "BUY", "symbols": ["TLT"]},  # Growth weak but cuts coming
            "hawkish": {"action": "BUY", "symbols": ["SPY", "QQQ"]},  # Growth strong
        }
    },
    "retail sales": {
        "type": "consumer",
        "weak_impact": "dovish",
        "strong_impact": "hawkish",
        "typical_shift": 3.0,
        "market_reaction": {
            "dovish": {"action": "BUY", "symbols": ["TLT"]},
            "hawkish": {"action": "BUY", "symbols": ["XLY", "SPY"]},  # Consumer discretionary
        }
    },
    
    # MANUFACTURING
    "ism manufacturing": {
        "type": "manufacturing",
        "weak_impact": "dovish",
        "strong_impact": "hawkish",
        "typical_shift": 2.0,
        "market_reaction": {
            "dovish": {"action": "BUY", "symbols": ["TLT"]},
            "hawkish": {"action": "BUY", "symbols": ["XLI", "SPY"]},
        }
    },
}


class EconomicExploitEngine:
    """
    Economic Data â†’ Fed Watch â†’ Market Exploit Engine.
    
    Predicts Fed Watch probability shifts based on economic releases
    and generates actionable trading signals.
    """
    
    def __init__(self, fed_watch_monitor=None, event_loader=None, perplexity_client=None):
        """
        Initialize the exploit engine.
        
        Args:
            fed_watch_monitor: FedWatchMonitor instance
            event_loader: EventLoader instance
            perplexity_client: PerplexitySearchClient for fallback
        """
        self.fed_watch_monitor = fed_watch_monitor
        self.event_loader = event_loader
        self.perplexity_client = perplexity_client
        
        # Historical tracking for learning
        self.prediction_history: List[Dict] = []
        
        logger.info("ðŸ“Š EconomicExploitEngine initialized")
    
    def _fetch_events_from_perplexity(self, date: str) -> List[Dict]:
        """
        Fallback: Get economic events from Perplexity.
        """
        if not self.perplexity_client:
            # Try to initialize
            try:
                api_key = os.getenv('PERPLEXITY_API_KEY')
                if api_key:
                    sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'enrichment', 'apis'))
                    from perplexity_search import PerplexitySearchClient
                    self.perplexity_client = PerplexitySearchClient(api_key=api_key)
            except:
                return []
        
        if not self.perplexity_client:
            return []
        
        query = f"""
        What are the major US economic data releases scheduled for {date}?
        Include:
        1. Time of release (in EST)
        2. Event name (NFP, CPI, PPI, etc.)
        3. Forecast/consensus if available
        4. Previous value
        Format each event as: TIME | EVENT NAME | FORECAST | PREVIOUS
        """
        
        try:
            result = self.perplexity_client.search(query)
            if not result or 'answer' not in result:
                return []
            
            answer = result['answer']
            events = []
            
            # Parse the response for events
            import re
            lines = answer.split('\n')
            for line in lines:
                # Look for time patterns like "8:30" or "08:30"
                time_match = re.search(r'(\d{1,2}:\d{2})', line)
                if time_match:
                    event = {
                        "time": time_match.group(1),
                        "name": line,
                        "impact": "high",  # Assume high impact from Perplexity results
                        "actual": "Pending",
                        "forecast": "N/A",
                        "previous": "N/A",
                        "surprise_sigma": None
                    }
                    
                    # Try to extract event name
                    for key in EVENT_FED_IMPACT.keys():
                        if key in line.lower():
                            event["name"] = key.replace('_', ' ').title()
                            break
                    
                    events.append(event)
            
            return events
            
        except Exception as e:
            logger.error(f"Error fetching from Perplexity: {e}")
            return []
    
    def analyze_upcoming_events(self, date: str = None) -> Dict:
        """
        Analyze upcoming economic events and predict market impact.
        
        Args:
            date: Date to analyze (YYYY-MM-DD), defaults to today
        
        Returns:
            {
                "date": "2025-12-05",
                "events": [EconomicEvent],
                "highest_impact_event": EconomicEvent,
                "overall_bias": "DOVISH" or "HAWKISH" or "NEUTRAL",
                "suggested_positioning": {...}
            }
        """
        if not date:
            date = datetime.now().strftime('%Y-%m-%d')
        
        logger.info(f"ðŸ“… Analyzing economic events for {date}")
        
        # Load events from calendar
        raw_events = None
        
        # Try EventLoader first
        try:
            if self.event_loader:
                raw_events = self.event_loader.load_events(date, min_impact="high")
            else:
                from live_monitoring.enrichment.apis.event_loader import EventLoader
                loader = EventLoader()
                raw_events = loader.load_events(date, min_impact="high")
        except Exception as e:
            logger.warning(f"EventLoader failed: {e}")
        
        # Fallback to Perplexity if no events
        if not raw_events or not raw_events.get('has_events'):
            perplexity_events = self._fetch_events_from_perplexity(date)
            if perplexity_events:
                raw_events = {
                    "date": date,
                    "macro_events": perplexity_events,
                    "has_events": True
                }
        
        if not raw_events or not raw_events.get('has_events'):
            return {
                "date": date,
                "events": [],
                "highest_impact_event": None,
                "overall_bias": "NEUTRAL",
                "suggested_positioning": None,
                "message": "No high-impact events scheduled"
            }
        
        # Process each event
        processed_events = []
        for raw in raw_events.get('macro_events', []):
            event = self._analyze_event(raw)
            if event:
                processed_events.append(event)
        
        # Find highest impact event
        highest_impact = None
        if processed_events:
            highest_impact = max(processed_events, key=lambda e: abs(e.expected_fed_watch_shift))
        
        # Calculate overall bias
        total_shift = sum(e.expected_fed_watch_shift for e in processed_events)
        if total_shift > 2:
            overall_bias = "DOVISH"  # More cuts expected
        elif total_shift < -2:
            overall_bias = "HAWKISH"  # Fewer cuts expected
        else:
            overall_bias = "NEUTRAL"
        
        return {
            "date": date,
            "events": processed_events,
            "highest_impact_event": highest_impact,
            "overall_bias": overall_bias,
            "total_expected_shift": total_shift,
            "suggested_positioning": self._get_suggested_positioning(overall_bias, processed_events)
        }
    
    def _analyze_event(self, raw_event: Dict) -> Optional[EconomicEvent]:
        """
        Analyze a single economic event for Fed impact.
        """
        name = raw_event.get('name', '').lower()
        
        # Find matching event type
        event_config = None
        for key, config in EVENT_FED_IMPACT.items():
            if key in name:
                event_config = config
                break
        
        if not event_config:
            return None
        
        # Determine surprise direction
        surprise = raw_event.get('surprise_sigma', 0) or 0
        
        if surprise > 0.5:  # Strong data
            direction = event_config['strong_impact']
            expected_shift = -event_config['typical_shift']  # Strong = fewer cuts
        elif surprise < -0.5:  # Weak data
            direction = event_config['weak_impact']
            expected_shift = event_config['typical_shift']  # Weak = more cuts
        else:  # In-line
            direction = "mixed"
            expected_shift = 0.0
        
        # Get trade signal
        trade_signal = ""
        trade_rationale = ""
        if direction in event_config.get('market_reaction', {}):
            reaction = event_config['market_reaction'][direction]
            trade_signal = f"{reaction['action']} {', '.join(reaction['symbols'])}"
            trade_rationale = f"{name.title()} surprise: {surprise:+.2f}Ïƒ â†’ {direction.upper()} â†’ Fed Watch shift {expected_shift:+.1f}%"
        
        return EconomicEvent(
            name=raw_event.get('name', name),
            time=raw_event.get('time', ''),
            actual=raw_event.get('actual'),
            forecast=raw_event.get('forecast'),
            previous=raw_event.get('previous'),
            impact=raw_event.get('impact', 'high'),
            surprise_sigma=surprise,
            fed_impact_type=EventImpactDirection.DOVISH if expected_shift > 0 else EventImpactDirection.HAWKISH,
            expected_fed_watch_shift=expected_shift,
            confidence=min(abs(surprise) * 30, 90),  # Higher surprise = higher confidence
            trade_signal=trade_signal,
            trade_rationale=trade_rationale
        )
    
    def _get_suggested_positioning(self, bias: str, events: List[EconomicEvent]) -> Dict:
        """
        Generate suggested positioning based on overall bias.
        """
        if bias == "DOVISH":
            return {
                "stance": "BULLISH",
                "primary_trades": ["BUY SPY", "BUY QQQ", "BUY TLT"],
                "rationale": "Weak economic data = More rate cuts = Bullish for stocks and bonds",
                "timing": "Position BEFORE or IMMEDIATELY on release",
                "risk_level": "MEDIUM"
            }
        elif bias == "HAWKISH":
            return {
                "stance": "CAUTIOUS",
                "primary_trades": ["REDUCE SPY", "REDUCE QQQ", "SELL TLT"],
                "rationale": "Strong economic data = Fewer rate cuts = Headwinds for stocks and bonds",
                "timing": "Wait for confirmation after release",
                "risk_level": "HIGH"
            }
        else:
            return {
                "stance": "NEUTRAL",
                "primary_trades": ["HOLD"],
                "rationale": "Mixed signals - wait for clearer direction",
                "timing": "Wait for data release",
                "risk_level": "LOW"
            }
    
    def generate_pre_release_signal(self, event: EconomicEvent, current_fed_watch: Dict) -> Optional[EconomicExploitSignal]:
        """
        Generate a PRE-RELEASE signal based on positioning.
        
        Strategy: Position before high-impact events based on:
        1. Current Fed Watch levels (if cut prob already very high, less room to move)
        2. Historical patterns
        3. Market consensus skew
        """
        if event.impact != 'high':
            return None
        
        # Get current Fed Watch
        current_cut = current_fed_watch.get('prob_cut', 50)
        
        # Determine positioning
        # If cut prob is >80%, expect less upside for dovish surprise
        # If cut prob is <30%, expect big move on dovish surprise
        
        room_for_dovish = 100 - current_cut  # Room for cut % to go up
        room_for_hawkish = current_cut  # Room for cut % to go down
        
        # If market expects weak data and it's weak â†’ less surprise
        # If market expects strong data and it's weak â†’ BIG surprise
        
        # For now, simple signal based on impact type
        name_lower = event.name.lower()
        
        # Employment data releases at 8:30 AM - position by 8:25 AM
        # CPI/PPI releases at 8:30 AM - position by 8:25 AM
        
        # Pre-release bias: If event is inflation, market is nervous
        # Position for likely scenarios
        
        event_config = None
        for key, config in EVENT_FED_IMPACT.items():
            if key in name_lower:
                event_config = config
                break
        
        if not event_config:
            return None
        
        # Generate pre-release signal based on typical market behavior
        # Strategy: "Fade the first move" or "Trade the expected"
        
        return EconomicExploitSignal(
            timestamp=datetime.now(),
            event_name=event.name,
            signal_type="PRE_RELEASE",
            action="WATCH",  # Pre-release is typically a "watch" signal
            symbols=["SPY", "QQQ", "TLT"],
            current_cut_prob=current_cut,
            predicted_cut_prob=current_cut,  # No prediction yet
            predicted_shift=0,
            confidence=40,  # Pre-release confidence is lower
            rationale=f"HIGH IMPACT EVENT: {event.name} at {event.time}. Be ready for {event_config['typical_shift']}% Fed Watch swing.",
            entry_timing="WAIT_FOR_RELEASE",
            stop_loss_pct=1.5,
            take_profit_pct=2.0
        )
    
    def generate_post_release_signal(self, event: EconomicEvent, current_fed_watch: Dict) -> Optional[EconomicExploitSignal]:
        """
        Generate a POST-RELEASE signal based on actual vs forecast.
        
        This is the MAIN exploit - after data is released, we know the surprise!
        """
        if event.actual == "Pending" or event.surprise_sigma is None:
            return None
        
        surprise = event.surprise_sigma
        current_cut = current_fed_watch.get('prob_cut', 50)
        
        # Determine signal based on surprise
        name_lower = event.name.lower()
        event_config = None
        for key, config in EVENT_FED_IMPACT.items():
            if key in name_lower:
                event_config = config
                break
        
        if not event_config:
            return None
        
        # Calculate predicted shift
        if abs(surprise) < 0.5:
            # In-line with expectations - no trade
            return None
        
        if surprise > 0:  # Strong data
            direction = event_config['strong_impact']
            predicted_shift = -event_config['typical_shift'] * min(abs(surprise), 3) / 2
            reaction = event_config['market_reaction'].get('hawkish', {})
        else:  # Weak data
            direction = event_config['weak_impact']
            predicted_shift = event_config['typical_shift'] * min(abs(surprise), 3) / 2
            reaction = event_config['market_reaction'].get('dovish', {})
        
        if not reaction:
            return None
        
        predicted_cut = current_cut + predicted_shift
        predicted_cut = max(0, min(100, predicted_cut))  # Clamp to 0-100
        
        return EconomicExploitSignal(
            timestamp=datetime.now(),
            event_name=event.name,
            signal_type="POST_RELEASE",
            action=reaction['action'],
            symbols=reaction['symbols'],
            current_cut_prob=current_cut,
            predicted_cut_prob=predicted_cut,
            predicted_shift=predicted_shift,
            confidence=min(abs(surprise) * 25 + 40, 95),  # Bigger surprise = higher confidence
            rationale=f"{event.name}: Actual {event.actual} vs Forecast {event.forecast} ({surprise:+.2f}Ïƒ surprise). Fed Watch should move {predicted_shift:+.1f}% â†’ {direction.upper()}",
            entry_timing="IMMEDIATE" if abs(surprise) > 1.5 else "WAIT_5MIN",
            stop_loss_pct=1.0 if abs(surprise) > 2 else 1.5,
            take_profit_pct=2.0 if abs(surprise) > 2 else 1.5
        )
    
    def get_next_week_calendar(self) -> List[Dict]:
        """
        Get high-impact events for the next 7 days.
        """
        events = []
        today = datetime.now()
        
        for i in range(7):
            date = (today + timedelta(days=i)).strftime('%Y-%m-%d')
            day_analysis = self.analyze_upcoming_events(date)
            
            if day_analysis.get('events'):
                events.append({
                    "date": date,
                    "day_name": (today + timedelta(days=i)).strftime('%A'),
                    "events": [e.name for e in day_analysis['events']],
                    "overall_bias": day_analysis['overall_bias'],
                    "highest_impact": day_analysis.get('highest_impact_event', {})
                })
        
        return events


# ========================================================================================
# DISPLAY / CLI
# ========================================================================================

def display_economic_analysis(analysis: Dict):
    """Display economic analysis in terminal."""
    print("\n" + "=" * 80)
    print(f"ðŸ“Š ECONOMIC EVENT ANALYSIS - {analysis['date']}")
    print("=" * 80)
    
    if not analysis.get('events'):
        print("   No high-impact events scheduled")
        return
    
    print(f"\nðŸ“ˆ Overall Bias: {analysis['overall_bias']}")
    print(f"   Expected Fed Watch Shift: {analysis.get('total_expected_shift', 0):+.1f}%")
    
    print("\nðŸ“… Events:")
    for event in analysis['events']:
        print(f"\n   ðŸ”” {event.name}")
        print(f"      Time: {event.time}")
        print(f"      Actual: {event.actual} | Forecast: {event.forecast}")
        if event.surprise_sigma:
            print(f"      Surprise: {event.surprise_sigma:+.2f}Ïƒ")
        print(f"      Fed Impact: {event.fed_impact_type.value.upper()}")
        print(f"      Expected Fed Watch Shift: {event.expected_fed_watch_shift:+.1f}%")
        if event.trade_signal:
            print(f"      ðŸ“Œ Trade Signal: {event.trade_signal}")
            print(f"         Rationale: {event.trade_rationale}")
    
    if analysis.get('suggested_positioning'):
        pos = analysis['suggested_positioning']
        print(f"\nðŸŽ¯ SUGGESTED POSITIONING:")
        print(f"   Stance: {pos['stance']}")
        print(f"   Trades: {', '.join(pos['primary_trades'])}")
        print(f"   Rationale: {pos['rationale']}")
        print(f"   Timing: {pos['timing']}")
        print(f"   Risk: {pos['risk_level']}")


# ========================================================================================
# DEMO / TEST
# ========================================================================================

def _demo():
    """Test the Economic Exploit Engine."""
    print("=" * 80)
    print("ðŸ§ª TESTING ECONOMIC EXPLOIT ENGINE")
    print("=" * 80)
    
    engine = EconomicExploitEngine()
    
    # Test today's events
    today = datetime.now().strftime('%Y-%m-%d')
    print(f"\nðŸ“… Analyzing events for TODAY ({today})...")
    analysis = engine.analyze_upcoming_events(today)
    display_economic_analysis(analysis)
    
    # Test next week
    print("\n" + "=" * 80)
    print("ðŸ“… NEXT WEEK'S HIGH-IMPACT EVENTS:")
    print("=" * 80)
    
    next_week = engine.get_next_week_calendar()
    for day in next_week:
        print(f"\n   {day['day_name']} ({day['date']}): {', '.join(day['events'][:3]) or 'No events'}")
        if day['events']:
            print(f"      Bias: {day['overall_bias']}")
    
    print("\n" + "=" * 80)
    print("âœ… Economic Exploit Engine test complete!")
    print("=" * 80)


if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s | %(levelname)s | %(message)s'
    )
    _demo()

