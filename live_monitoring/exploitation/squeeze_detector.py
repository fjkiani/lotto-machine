#!/usr/bin/env python3
"""
üî• SQUEEZE DETECTOR - ALPHA'S MONEY MAKER üí∞
============================================

Detects short squeeze setups using:
- Short Interest (SI%) 
- Borrow Fee Rate
- Failure to Deliver (FTD) spikes
- Dark Pool Support Levels

Score Calculation (0-100):
- SI Score: min(SI% / 30 * 100, 40) - max 40 points
- Borrow Fee Score: min(fee / 100 * 100, 30) - max 30 points  
- FTD Score: min(spike_ratio / 3 * 100, 20) - max 20 points
- DP Support Score: buying_pressure * 10 - max 10 points

Signal generated if score > 70

NO MOCK DATA. Returns None if API fails.
"""

import logging
from datetime import datetime
from typing import Optional, List, Dict, Any
from dataclasses import dataclass, field
import os
import sys

# Add project root to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

from core.data.ultimate_chartexchange_client import UltimateChartExchangeClient
from live_monitoring.core.lottery_signals import LiveSignal, SignalType, SignalAction

logger = logging.getLogger(__name__)


@dataclass
class SqueezeSignal:
    """
    Squeeze signal with all the juicy details üî•
    """
    symbol: str
    score: float  # 0-100
    
    # Component scores
    si_score: float
    borrow_fee_score: float
    ftd_score: float
    dp_support_score: float
    
    # Raw data
    short_interest_pct: float
    borrow_fee_pct: float
    ftd_spike_ratio: float
    dp_buying_pressure: float
    
    # Trade setup
    action: str  # Always "LONG" for squeezes
    entry_price: float
    stop_price: float
    target_price: float
    risk_reward_ratio: float
    
    # Context
    reasoning: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.now)
    
    # DP context
    nearest_dp_support: Optional[float] = None
    nearest_dp_resistance: Optional[float] = None


class SqueezeDetector:
    """
    Detects short squeeze setups using multiple data sources.
    
    Uses UltimateChartExchangeClient directly - no wrapper bullshit.
    """
    
    # Scoring thresholds
    # NOTE: Borrow fee data often unavailable (returns 0%), so threshold adjusted
    SIGNAL_THRESHOLD = 55  # Best threshold: 55 (50% win rate, 8 trades, PF 2.09)
    
    # Score weights (max points) - Adjusted for missing borrow fee
    # Original: SI=40, Borrow=30, FTD=20, DP=10 = 100
    # New: SI=50, Borrow=10, FTD=25, DP=15 = 100 (less reliance on borrow fee)
    MAX_SI_SCORE = 50        # Increased - SI is the primary indicator
    MAX_BORROW_SCORE = 10    # Reduced - often unavailable
    MAX_FTD_SCORE = 25       # Increased - good secondary indicator
    MAX_DP_SCORE = 15        # Increased - DP support matters
    
    # SI thresholds - Adjusted for better sensitivity
    SI_MAX_REFERENCE = 25.0  # 25% SI = max SI points (was 30%)
    
    # Borrow fee thresholds  
    BORROW_FEE_MAX_REFERENCE = 100.0  # 100% annual = max borrow points
    
    # FTD spike thresholds - More sensitive
    FTD_SPIKE_MAX_REFERENCE = 2.0  # 2x spike = max FTD points (was 3x)
    
    # Target/Stop settings
    DEFAULT_TARGET_PCT = 0.10  # 10% target
    MIN_STOP_PCT = 0.005  # 0.5% minimum stop
    FALLBACK_STOP_PCT = 0.02  # 2% fallback if no DP support
    DP_STOP_BUFFER_PCT = 0.01  # 1% below DP support
    MIN_RR_RATIO = 2.5  # Task 3: Widen target to 2.5:1 (was 2.0) for better profit factor
    
    def __init__(self, client: UltimateChartExchangeClient):
        """
        Initialize with existing ChartExchange client.
        No wrapper - use the fucking client directly.
        """
        self.client = client
        logger.info("üî• SqueezeDetector initialized - ready to find money!")
    
    def analyze(self, symbol: str, current_price: Optional[float] = None, 
                date: Optional[datetime] = None, regime: Optional[str] = None) -> Optional[SqueezeSignal]:
        """
        Analyze a symbol for squeeze potential.
        
        Returns SqueezeSignal if score > threshold, else None.
        Returns None if any critical data fetch fails.
        
        Args:
            symbol: Stock ticker (e.g., "SPY", "QQQ")
            current_price: Current price (will fetch if not provided)
            date: Historical date to analyze (defaults to today for current data)
            regime: Market regime (UPTREND, DOWNTREND, CHOPPY, etc.) - filters out bearish regimes
        """
        date_str = date.strftime('%Y-%m-%d') if date else None
        date_label = f" on {date_str}" if date_str else ""
        logger.info(f"üîç Analyzing {symbol}{date_label} for squeeze potential...")
        
        # Task 2: Regime filter REMOVED - squeezes can happen in any regime
        # (Tested: filtering downtrends reduced win rate from 50% to 40%)
        
        # Step 1: Fetch all data (with historical date support)
        short_data = self._fetch_short_interest(symbol, date=date_str)
        if short_data is None:
            logger.debug(f"{symbol}: Failed to get short interest - skipping")
            return None
        
        borrow_data = self._fetch_borrow_fee(symbol, date=date_str)
        if borrow_data is None:
            logger.debug(f"{symbol}: Failed to get borrow fee - using 0")
            borrow_data = {'fee_rate': 0.0}
        
        ftd_data = self._fetch_ftd_data(symbol, date=date_str)
        if ftd_data is None:
            logger.debug(f"{symbol}: Failed to get FTD data - using 0")
            ftd_data = []
        
        dp_levels = self._fetch_dp_levels(symbol, date=date_str)
        dp_prints = self._fetch_dp_prints(symbol, date=date_str)
        
        # Get current price if not provided
        if current_price is None:
            current_price = self._get_current_price(symbol)
            if current_price is None:
                logger.warning(f"{symbol}: Failed to get current price - skipping")
                return None
        
        # Step 2: Calculate component scores
        si_pct = self._extract_si_pct(short_data)
        borrow_fee = self._extract_borrow_fee(borrow_data)
        ftd_spike = self._calculate_ftd_spike(ftd_data)
        dp_buying_pressure = self._calculate_buying_pressure(dp_prints)
        
        si_score = min((si_pct / self.SI_MAX_REFERENCE) * self.MAX_SI_SCORE, self.MAX_SI_SCORE)
        borrow_score = min((borrow_fee / self.BORROW_FEE_MAX_REFERENCE) * self.MAX_BORROW_SCORE, self.MAX_BORROW_SCORE)
        ftd_score = min((ftd_spike / self.FTD_SPIKE_MAX_REFERENCE) * self.MAX_FTD_SCORE, self.MAX_FTD_SCORE)
        dp_score = min(dp_buying_pressure * self.MAX_DP_SCORE, self.MAX_DP_SCORE)
        
        total_score = si_score + borrow_score + ftd_score + dp_score
        
        logger.info(f"   üìä {symbol} Squeeze Score: {total_score:.1f}/100")
        logger.info(f"      SI: {si_pct:.1f}% ({si_score:.1f} pts)")
        logger.info(f"      Borrow: {borrow_fee:.1f}% ({borrow_score:.1f} pts)")
        logger.info(f"      FTD Spike: {ftd_spike:.2f}x ({ftd_score:.1f} pts)")
        logger.info(f"      DP Buying: {dp_buying_pressure:.1%} ({dp_score:.1f} pts)")
        
        # Step 3: Check threshold
        if total_score < self.SIGNAL_THRESHOLD:
            logger.info(f"   ‚ùå Score {total_score:.1f} < {self.SIGNAL_THRESHOLD} threshold - no signal")
            return None
        
        # Task 4: Momentum filter REMOVED - reduced win rate from 50% to 25%
        
        # Step 4: Calculate trade setup
        nearest_support, nearest_resistance = self._find_dp_levels(dp_levels, current_price)
        
        entry = current_price
        stop = self._calculate_stop(current_price, nearest_support)
        target = self._calculate_target(current_price, nearest_resistance)
        
        # Ensure minimum R/R
        risk = entry - stop
        reward = target - entry
        
        if risk <= 0:
            logger.warning(f"   ‚ö†Ô∏è Invalid risk calculation - adjusting stop")
            stop = entry * (1 - self.FALLBACK_STOP_PCT)
            risk = entry - stop
        
        rr_ratio = reward / risk if risk > 0 else 0
        
        if rr_ratio < self.MIN_RR_RATIO:
            # Bump up target to meet minimum R/R
            target = entry + (risk * self.MIN_RR_RATIO)
            reward = target - entry
            rr_ratio = reward / risk
            logger.info(f"   üìà Adjusted target to ${target:.2f} for {self.MIN_RR_RATIO}:1 R/R")
        
        # Step 5: Build reasoning
        reasoning = []
        warnings = []
        
        if si_pct >= 15:
            reasoning.append(f"High SI: {si_pct:.1f}% of float is short")
        if borrow_fee >= 10:
            reasoning.append(f"Elevated borrow: {borrow_fee:.1f}% annual cost to short")
        if ftd_spike >= 1.5:
            reasoning.append(f"FTD spike: {ftd_spike:.1f}x above average")
        if dp_buying_pressure >= 0.6:
            reasoning.append(f"Strong DP buying: {dp_buying_pressure:.0%} buy-side pressure")
        
        if si_pct < 10:
            warnings.append(f"Low SI ({si_pct:.1f}%) - limited squeeze potential")
        if borrow_fee < 1:
            warnings.append(f"Very low borrow fee ({borrow_fee:.1f}%) - easy to short")
        if nearest_support is None:
            warnings.append("No DP support found - using fallback stop")
        
        # Step 6: Create signal
        signal = SqueezeSignal(
            symbol=symbol,
            score=total_score,
            si_score=si_score,
            borrow_fee_score=borrow_score,
            ftd_score=ftd_score,
            dp_support_score=dp_score,
            short_interest_pct=si_pct,
            borrow_fee_pct=borrow_fee,
            ftd_spike_ratio=ftd_spike,
            dp_buying_pressure=dp_buying_pressure,
            action="LONG",
            entry_price=entry,
            stop_price=stop,
            target_price=target,
            risk_reward_ratio=rr_ratio,
            reasoning=reasoning,
            warnings=warnings,
            nearest_dp_support=nearest_support,
            nearest_dp_resistance=nearest_resistance
        )
        
        logger.info(f"   üî• SQUEEZE SIGNAL GENERATED!")
        logger.info(f"      Score: {total_score:.1f}/100")
        logger.info(f"      Entry: ${entry:.2f} | Stop: ${stop:.2f} | Target: ${target:.2f}")
        logger.info(f"      R/R: {rr_ratio:.1f}:1")
        
        return signal
    
    def to_live_signal(self, squeeze: SqueezeSignal) -> LiveSignal:
        """
        Convert SqueezeSignal to LiveSignal for alert system.
        """
        return LiveSignal(
            symbol=squeeze.symbol,
            action=SignalAction.BUY,
            timestamp=squeeze.timestamp,
            entry_price=squeeze.entry_price,
            target_price=squeeze.target_price,
            stop_price=squeeze.stop_price,
            confidence=squeeze.score / 100.0,
            signal_type=SignalType.SQUEEZE,
            rationale=f"SQUEEZE SETUP: Score {squeeze.score:.0f}/100 | SI: {squeeze.short_interest_pct:.1f}% | Borrow: {squeeze.borrow_fee_pct:.1f}%",
            supporting_factors=squeeze.reasoning,
            warnings=squeeze.warnings,
            is_master_signal=squeeze.score >= 80,
            is_actionable=True,
            risk_reward_ratio=squeeze.risk_reward_ratio,
            dp_level=squeeze.nearest_dp_support or 0.0,
            institutional_score=squeeze.dp_buying_pressure * 100
        )
    
    # ==================== DATA FETCHING ====================
    
    def _fetch_short_interest(self, symbol: str, date: Optional[str] = None) -> Optional[Dict]:
        """
        Fetch short interest data.
        
        Uses get_short_interest_daily() for historical dates (more accurate),
        falls back to get_short_interest() for current data.
        """
        try:
            if date:
                # Use daily endpoint for historical dates
                data = self.client.get_short_interest_daily(symbol, date=date)
                # Returns list, get most recent entry
                if data and isinstance(data, list) and len(data) > 0:
                    return data[0]  # Most recent entry for that date
                return None
            else:
                # Current data - use main endpoint (returns list)
                data = self.client.get_short_interest(symbol)
                if data and isinstance(data, list) and len(data) > 0:
                    return data[0]  # Most recent entry
                return None
        except Exception as e:
            logger.error(f"Failed to fetch short interest for {symbol}: {e}")
            return None
    
    def _fetch_borrow_fee(self, symbol: str, date: Optional[str] = None) -> Optional[Dict]:
        """Fetch borrow fee data (supports historical dates)"""
        try:
            data = self.client.get_borrow_fee(symbol, date=date)
            if data:
                return {'fee_rate': data.fee_rate, 'available': data.available_shares}
            return None
        except Exception as e:
            logger.error(f"Failed to fetch borrow fee for {symbol}: {e}")
            return None
    
    def _fetch_ftd_data(self, symbol: str, date: Optional[str] = None) -> Optional[List]:
        """
        Fetch FTD data.
        
        For historical dates, fetches data around that date (30 days before).
        For current dates, fetches last 30 days.
        """
        try:
            if date:
                # Calculate start_date as 30 days before target date
                from datetime import datetime, timedelta
                target_date = datetime.strptime(date, '%Y-%m-%d')
                start_date = (target_date - timedelta(days=30)).strftime('%Y-%m-%d')
                data = self.client.get_failure_to_deliver(symbol, start_date=start_date)
            else:
                data = self.client.get_failure_to_deliver(symbol)
            return data if data else []
        except Exception as e:
            logger.error(f"Failed to fetch FTD data for {symbol}: {e}")
            return None
    
    def _fetch_dp_levels(self, symbol: str, date: Optional[str] = None) -> List[Dict]:
        """Fetch dark pool levels (supports historical dates)"""
        try:
            data = self.client.get_dark_pool_levels(symbol, date=date)
            return data if data else []
        except Exception as e:
            logger.error(f"Failed to fetch DP levels for {symbol}: {e}")
            return []
    
    def _fetch_dp_prints(self, symbol: str, date: Optional[str] = None) -> Optional[Dict]:
        """Fetch dark pool print summary (supports historical dates)"""
        try:
            # get_dark_pool_summary might not support date, try with date first
            data = self.client.get_dark_pool_summary(symbol)
            # If date provided, filter to that date's data if possible
            # For now, just return summary (API might not support date filtering)
            return data
        except Exception as e:
            logger.error(f"Failed to fetch DP prints for {symbol}: {e}")
            return None
    
    def _get_current_price(self, symbol: str) -> Optional[float]:
        """Get current price - try DP levels first, fallback to yfinance"""
        try:
            # Try to get from DP levels (most recent)
            dp_levels = self.client.get_dark_pool_levels(symbol)
            if dp_levels and len(dp_levels) > 0:
                # Get the level closest to average of all levels
                prices = [float(l.get('level', 0)) for l in dp_levels if l.get('level')]
                if prices:
                    # Return average as proxy for current price
                    return sum(prices) / len(prices)
            
            # Fallback to yfinance
            import yfinance as yf
            ticker = yf.Ticker(symbol)
            hist = ticker.history(period='1d')
            if not hist.empty:
                return float(hist['Close'].iloc[-1])
            
            return None
        except Exception as e:
            logger.error(f"Failed to get current price for {symbol}: {e}")
            return None
    
    # ==================== DATA EXTRACTION ====================
    
    def _extract_si_pct(self, data) -> float:
        """Extract short interest percentage from API response"""
        if data is None:
            return 0.0
        
        # Handle list (historical data) - get most recent
        if isinstance(data, list):
            if len(data) == 0:
                return 0.0
            data = data[0]  # Most recent entry
        
        # Handle dict
        if isinstance(data, dict):
            # ChartExchange returns 'short_interest' as a percentage string like '10.82'
            for field in ['short_interest', 'short_interest_pct', 'short_pct', 'si_pct']:
                if field in data:
                    try:
                        return float(data[field])
                    except (ValueError, TypeError):
                        pass
            
            # Calculate from raw numbers if available
            si = data.get('short_position', 0)
            float_shares = data.get('float_shares', data.get('shares_float', 0))
            
            if si and float_shares and float_shares > 0:
                return (si / float_shares) * 100
        
        return 0.0
    
    def _extract_borrow_fee(self, data: Dict) -> float:
        """Extract borrow fee from data"""
        if data is None:
            return 0.0
        
        return float(data.get('fee_rate', 0))
    
    def _calculate_ftd_spike(self, ftd_data: List) -> float:
        """
        Calculate FTD spike ratio.
        current_ftd / average_ftd over available data
        """
        if not ftd_data or len(ftd_data) == 0:
            return 0.0
        
        # Extract quantities
        quantities = []
        for entry in ftd_data:
            if isinstance(entry, dict):
                qty = entry.get('quantity', 0)
            elif hasattr(entry, 'quantity'):
                qty = entry.quantity
            else:
                continue
            
            try:
                quantities.append(int(qty))
            except (ValueError, TypeError):
                pass
        
        if not quantities:
            return 0.0
        
        # Most recent is "current", rest is average
        if len(quantities) == 1:
            return 1.0  # No historical data, assume normal
        
        current = quantities[0]  # Assuming sorted by date desc
        avg_historical = sum(quantities[1:]) / len(quantities[1:])
        
        if avg_historical <= 0:
            return 1.0
        
        return current / avg_historical
    
    def _calculate_buying_pressure(self, dp_summary: Optional[Dict]) -> float:
        """
        Calculate DP buying pressure.
        buy_volume / (buy_volume + sell_volume)
        Returns 0-1 (0.5 = neutral)
        """
        if dp_summary is None:
            return 0.5  # Neutral if no data
        
        # Handle DarkPoolPrintSummary dataclass
        if hasattr(dp_summary, 'buy_volume'):
            buy_vol = dp_summary.buy_volume
            sell_vol = dp_summary.sell_volume
        else:
            buy_vol = dp_summary.get('buy_volume', 0)
            sell_vol = dp_summary.get('sell_volume', 0)
        
        total = buy_vol + sell_vol
        if total <= 0:
            return 0.5
        
        return buy_vol / total
    
    def _check_momentum(self, symbol: str, date: Optional[datetime] = None) -> bool:
        """
        Check if price has positive momentum (5-bar lookback)
        Only take squeeze signals when momentum is positive
        
        Args:
            symbol: Stock ticker
            date: Historical date (if None, uses today)
        """
        try:
            import yfinance as yf
            from datetime import timedelta
            
            ticker = yf.Ticker(symbol)
            
            if date:
                # For historical dates, get data up to that date
                # yfinance 1m data only available for last 7 days
                # So for historical dates, use daily data instead
                hist = ticker.history(
                    start=(date - timedelta(days=2)).strftime('%Y-%m-%d'),
                    end=date.strftime('%Y-%m-%d'),
                    interval='1d'
                )
                if len(hist) < 2:
                    return True  # Not enough data, allow signal
                recent_close = hist['Close'].iloc[-1]
                past_close = hist['Close'].iloc[0]
            else:
                # Current date - use 5m data
                data = ticker.history(period='1d', interval='5m')
                if len(data) < 6:
                    return True  # Not enough data, allow signal
                recent_close = data['Close'].iloc[-1]
                past_close = data['Close'].iloc[-6]  # 30 min ago
            
            momentum = (recent_close - past_close) / past_close
            
            # Require at least 0.1% positive momentum
            return momentum > 0.001
        except Exception as e:
            logger.debug(f"Momentum check failed for {symbol}: {e}")
            return True  # On error, allow signal (fail-safe)
    
    # ==================== TRADE CALCULATION ====================
    
    def _find_dp_levels(self, dp_levels: List[Dict], current_price: float) -> tuple:
        """
        Find nearest DP support and resistance levels.
        Returns (nearest_support, nearest_resistance)
        """
        if not dp_levels or current_price is None:
            return None, None
        
        support = None
        resistance = None
        
        for level_data in dp_levels:
            try:
                price = float(level_data.get('level', level_data.get('price', 0)))
                if price <= 0:
                    continue
                
                if price < current_price:
                    # Support level
                    if support is None or price > support:
                        support = price
                else:
                    # Resistance level
                    if resistance is None or price < resistance:
                        resistance = price
            except (ValueError, TypeError):
                continue
        
        return support, resistance
    
    def _calculate_stop(self, entry: float, dp_support: Optional[float]) -> float:
        """
        Calculate stop loss.
        - DP support - 1% if available
        - Entry - 2% fallback
        - Minimum 0.5% from entry
        """
        if dp_support is not None:
            stop = dp_support * (1 - self.DP_STOP_BUFFER_PCT)
        else:
            stop = entry * (1 - self.FALLBACK_STOP_PCT)
        
        # Ensure minimum distance
        min_stop = entry * (1 - self.MIN_STOP_PCT)
        if stop > min_stop:
            stop = min_stop
        
        return stop
    
    def _calculate_target(self, entry: float, dp_resistance: Optional[float]) -> float:
        """
        Calculate target price.
        - Next DP resistance if closer than 10%
        - Entry + 10% otherwise
        """
        default_target = entry * (1 + self.DEFAULT_TARGET_PCT)
        
        if dp_resistance is not None:
            # Use whichever is closer: DP resistance or 10%
            return min(dp_resistance, default_target)
        
        return default_target
    
    def scan_watchlist(self, symbols: List[str]) -> List[SqueezeSignal]:
        """
        Scan a list of symbols for squeeze setups.
        Returns list of signals (score > 70).
        """
        signals = []
        
        for symbol in symbols:
            try:
                signal = self.analyze(symbol)
                if signal:
                    signals.append(signal)
            except Exception as e:
                logger.error(f"Error analyzing {symbol}: {e}")
                continue
        
        # Sort by score descending
        signals.sort(key=lambda x: x.score, reverse=True)
        
        return signals


# ==================== STANDALONE TEST ====================

if __name__ == "__main__":
    import os
    from dotenv import load_dotenv
    
    load_dotenv()
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    
    api_key = os.getenv('CHART_EXCHANGE_API_KEY')
    if not api_key:
        print("‚ùå CHART_EXCHANGE_API_KEY not set!")
        sys.exit(1)
    
    print("\n" + "="*60)
    print("üî• SQUEEZE DETECTOR TEST")
    print("="*60)
    
    client = UltimateChartExchangeClient(api_key, tier=3)
    detector = SqueezeDetector(client)
    
    # Test with SPY and QQQ
    test_symbols = ['SPY', 'QQQ']
    
    for symbol in test_symbols:
        print(f"\n{'='*40}")
        print(f"Testing {symbol}")
        print('='*40)
        
        signal = detector.analyze(symbol)
        
        if signal:
            print(f"\n‚úÖ SQUEEZE SIGNAL FOUND!")
            print(f"   Score: {signal.score:.1f}/100")
            print(f"   SI%: {signal.short_interest_pct:.1f}%")
            print(f"   Borrow Fee: {signal.borrow_fee_pct:.1f}%")
            print(f"   FTD Spike: {signal.ftd_spike_ratio:.2f}x")
            print(f"   DP Buying: {signal.dp_buying_pressure:.0%}")
            print(f"   Entry: ${signal.entry_price:.2f}")
            print(f"   Stop: ${signal.stop_price:.2f}")
            print(f"   Target: ${signal.target_price:.2f}")
            print(f"   R/R: {signal.risk_reward_ratio:.1f}:1")
            print(f"   Reasoning: {signal.reasoning}")
            if signal.warnings:
                print(f"   Warnings: {signal.warnings}")
        else:
            print(f"\n‚ùå No squeeze signal for {symbol}")
    
    print("\n" + "="*60)
    print("‚úÖ TEST COMPLETE")
    print("="*60)

