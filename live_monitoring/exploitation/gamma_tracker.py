"""
üé≤ GAMMA TRACKER - Phase 2 Exploitation Module

Tracks dealer gamma exposure and generates signals when:
- Low P/C ratio + Max Pain above = GAMMA RAMP UP (bullish)
- High P/C ratio + Max Pain below = GAMMA RAMP DOWN (bearish)

Data Source: yfinance (ChartExchange options API returning 400s)
"""

import logging
import sys
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, List, Dict
import pandas as pd
import yfinance as yf

logger = logging.getLogger(__name__)


@dataclass
class GammaSignal:
    """Gamma-based trading signal"""
    symbol: str
    timestamp: datetime
    direction: str  # UP, DOWN
    score: float  # 0-100
    
    # Gamma metrics
    put_call_ratio: float
    max_pain: float
    max_pain_distance_pct: float
    current_price: float
    
    # OI data
    total_call_oi: int
    total_put_oi: int
    
    # Trade setup
    action: str  # LONG, SHORT
    entry_price: float
    target_price: float  # Max pain is the target
    stop_price: float
    risk_reward_ratio: float
    
    # Reasoning
    reasoning: List[str]
    expiration: str


class GammaTracker:
    """
    Gamma exposure tracker using options data.
    
    Logic:
    - Dealers are short options (sold to retail)
    - When net gamma is positive (more calls than puts), dealers BUY dips and SELL rallies
    - When net gamma is negative (more puts than calls), dealers SELL dips and BUY rallies
    - Price tends to gravitate toward max pain (where most options expire worthless)
    """
    
    # Signal thresholds
    MIN_PC_FOR_BULLISH = 0.7  # P/C < 0.7 = bullish gamma
    MAX_PC_FOR_BEARISH = 1.3  # P/C > 1.3 = bearish gamma
    MIN_DISTANCE_PCT = 1.0    # Min 1% distance to max pain for signal
    MIN_SCORE = 50            # Minimum score to generate signal
    
    # Scoring weights
    PC_WEIGHT = 40            # Put/call ratio weight
    DISTANCE_WEIGHT = 30      # Distance to max pain weight
    OI_WEIGHT = 30            # Open interest concentration weight
    
    # Risk parameters
    STOP_DISTANCE_PCT = 0.5   # 0.5% stop loss
    MIN_RR_RATIO = 2.0        # Minimum 2:1 R/R
    
    def __init__(self):
        """Initialize gamma tracker"""
        logger.info("üé≤ GammaTracker initialized")
    
    def analyze(self, symbol: str, current_price: Optional[float] = None, 
                expiration_idx: int = 0, regime: Optional[str] = None) -> Optional[GammaSignal]:
        """
        Analyze gamma exposure for a symbol.
        
        Args:
            symbol: Stock ticker (e.g., "SPY", "QQQ")
            current_price: Current price (will fetch if not provided)
            expiration_idx: Which expiration to use (0=nearest, 1=next, etc.)
            
        Returns:
            GammaSignal if conditions met, None otherwise
        """
        logger.info(f"üîç Analyzing {symbol} for gamma exposure...")
        
        try:
            # Step 1: Get options data from yfinance
            ticker = yf.Ticker(symbol)
            
            # Get current price if not provided
            if current_price is None:
                hist = ticker.history(period='1d')
                if hist.empty:
                    logger.warning(f"   ‚ùå Failed to get price for {symbol}")
                    return None
                current_price = float(hist['Close'].iloc[-1])
            
            logger.info(f"   Current price: ${current_price:.2f}")
            
            # Get nearest expiration
            expirations = ticker.options
            if not expirations:
                logger.warning(f"   ‚ùå No options expirations available for {symbol}")
                return None
            
            # Task 4: Smart expiration selection
            # If expiration_idx is 0 (default), use smart selection
            # Otherwise use specified index
            if expiration_idx == 0:
                exp_idx = self._select_best_expiration(symbol, expirations)
                if exp_idx is None:
                    logger.warning(f"   ‚ùå No suitable expiration found for {symbol}")
                    return None
            else:
                exp_idx = min(expiration_idx, len(expirations) - 1)
            
            nearest_exp = expirations[exp_idx]
            logger.info(f"   Using expiration: {nearest_exp} (index {exp_idx})")
            
            # Get options chain
            chain = ticker.option_chain(nearest_exp)
            calls = chain.calls
            puts = chain.puts
            
            # Step 2: Calculate gamma metrics
            total_call_oi = int(calls['openInterest'].sum())
            total_put_oi = int(puts['openInterest'].sum())
            
            if total_call_oi == 0:
                logger.warning(f"   ‚ùå No call OI for {symbol}")
                return None
            
            pc_ratio = total_put_oi / total_call_oi
            logger.info(f"   P/C Ratio: {pc_ratio:.2f}")
            logger.info(f"   Total Call OI: {total_call_oi:,}")
            logger.info(f"   Total Put OI: {total_put_oi:,}")
            
            # Step 3: Calculate max pain
            max_pain = self._calculate_max_pain(calls, puts, current_price)
            if max_pain is None:
                logger.warning(f"   ‚ùå Could not calculate max pain for {symbol}")
                return None
            
            max_pain_distance = (max_pain - current_price) / current_price * 100
            logger.info(f"   Max Pain: ${max_pain:.2f} ({max_pain_distance:+.2f}%)")
            
            # Step 4: Check signal conditions
            direction = None
            reasoning = []
            
            if pc_ratio < self.MIN_PC_FOR_BULLISH and max_pain_distance > self.MIN_DISTANCE_PCT:
                # Bullish gamma ramp
                direction = 'UP'
                reasoning.append(f"Low P/C ratio ({pc_ratio:.2f} < {self.MIN_PC_FOR_BULLISH})")
                reasoning.append(f"Max pain ${max_pain:.2f} is {max_pain_distance:.1f}% ABOVE price")
                reasoning.append("Dealers will BUY to hedge calls ‚Üí bullish pressure")
            
            elif pc_ratio > self.MAX_PC_FOR_BEARISH and max_pain_distance < -self.MIN_DISTANCE_PCT:
                # Bearish gamma ramp
                direction = 'DOWN'
                reasoning.append(f"High P/C ratio ({pc_ratio:.2f} > {self.MAX_PC_FOR_BEARISH})")
                reasoning.append(f"Max pain ${max_pain:.2f} is {abs(max_pain_distance):.1f}% BELOW price")
                reasoning.append("Dealers will SELL to hedge puts ‚Üí bearish pressure")
            
            if direction is None:
                logger.info(f"   ‚ùå No gamma signal - P/C {pc_ratio:.2f}, distance {max_pain_distance:+.1f}%")
                return None
            
            # Step 5: Calculate score
            score = self._calculate_score(pc_ratio, max_pain_distance, total_call_oi, total_put_oi, direction)
            logger.info(f"   Gamma score: {score:.1f}/100")
            
            if score < self.MIN_SCORE:
                logger.info(f"   ‚ùå Score {score:.1f} < {self.MIN_SCORE} threshold - no signal")
                return None
            
            # Step 6: Calculate trade setup
            action = 'LONG' if direction == 'UP' else 'SHORT'
            entry = current_price
            target = max_pain  # Target is max pain
            
            if action == 'LONG':
                stop = entry * (1 - self.STOP_DISTANCE_PCT / 100)
                risk = entry - stop
                reward = target - entry
            else:  # SHORT
                stop = entry * (1 + self.STOP_DISTANCE_PCT / 100)
                risk = stop - entry
                reward = entry - target
            
            rr_ratio = reward / risk if risk > 0 else 0
            
            # Adjust target if R/R too low
            if rr_ratio < self.MIN_RR_RATIO:
                if action == 'LONG':
                    target = entry + (risk * self.MIN_RR_RATIO)
                else:
                    target = entry - (risk * self.MIN_RR_RATIO)
                rr_ratio = self.MIN_RR_RATIO
                reasoning.append(f"Target adjusted to ${target:.2f} for {self.MIN_RR_RATIO}:1 R/R")
            
            # Step 7: Build signal
            signal = GammaSignal(
                symbol=symbol,
                timestamp=datetime.now(),
                direction=direction,
                score=score,
                put_call_ratio=pc_ratio,
                max_pain=max_pain,
                max_pain_distance_pct=max_pain_distance,
                current_price=current_price,
                total_call_oi=total_call_oi,
                total_put_oi=total_put_oi,
                action=action,
                entry_price=entry,
                target_price=target,
                stop_price=stop,
                risk_reward_ratio=rr_ratio,
                reasoning=reasoning,
                expiration=nearest_exp
            )
            
            # Task 7: Regime filter (if provided)
            if regime:
                if signal.direction == 'UP' and regime in ['DOWNTREND', 'STRONG_DOWNTREND', 'RISK_OFF']:
                    logger.info(f"   ‚è∏Ô∏è {symbol}: Skipping bullish gamma - bearish regime ({regime})")
                    return None
                elif signal.direction == 'DOWN' and regime in ['UPTREND', 'STRONG_UPTREND', 'RISK_ON']:
                    logger.info(f"   ‚è∏Ô∏è {symbol}: Skipping bearish gamma - bullish regime ({regime})")
                    return None
            
            logger.info(f"   üî• GAMMA SIGNAL GENERATED!")
            logger.info(f"      Direction: {direction}")
            logger.info(f"      Action: {action}")
            logger.info(f"      Entry: ${entry:.2f}")
            logger.info(f"      Target: ${target:.2f} (max pain)")
            logger.info(f"      Stop: ${stop:.2f}")
            logger.info(f"      R/R: {rr_ratio:.1f}:1")
            
            return signal
            
        except Exception as e:
            logger.error(f"   ‚ùå Error analyzing {symbol}: {e}")
            return None
    
    def _select_best_expiration(self, symbol: str, expirations: List[str]) -> Optional[int]:
        """
        Select the expiration with highest gamma signal potential.
        
        Rules:
        1. Skip 0-1 DTE (too much noise)
        2. Prefer 3-7 DTE (gamma sweet spot)
        3. Check P/C ratio across expirations
        4. Return index of best expiration
        
        Args:
            symbol: Stock ticker
            expirations: List of expiration dates
            
        Returns:
            Index of best expiration, or None if none suitable
        """
        import yfinance as yf
        from datetime import datetime
        
        ticker = yf.Ticker(symbol)
        best_exp_idx = None
        best_score = 0
        
        for i, exp_str in enumerate(expirations[:15]):  # Check first 15 expirations
            try:
                # Calculate days to expiration
                exp_date = datetime.strptime(exp_str, '%Y-%m-%d')
                days_to_exp = (exp_date - datetime.now()).days
                
                # Skip 0-1 DTE (too much noise)
                if days_to_exp < 2:
                    continue
                
                # Get options chain
                chain = ticker.option_chain(exp_str)
                call_oi = chain.calls['openInterest'].sum()
                put_oi = chain.puts['openInterest'].sum()
                
                # Need both call and put OI for valid P/C ratio
                if call_oi == 0 or put_oi == 0:
                    continue
                
                pc_ratio = put_oi / call_oi
                
                # Score based on:
                # 1. P/C extremity (further from 1.0 = better signal potential)
                # 2. DTE preference (3-7 days = sweet spot)
                pc_score = abs(pc_ratio - 1.0)  # Further from 1.0 = better
                
                # DTE preference: 3-7 days gets bonus
                if 3 <= days_to_exp <= 7:
                    dte_bonus = 0.3
                elif 2 <= days_to_exp <= 14:
                    dte_bonus = 0.1
                else:
                    dte_bonus = 0.0
                
                total_score = pc_score + dte_bonus
                
                if total_score > best_score:
                    best_score = total_score
                    best_exp_idx = i
            except Exception as e:
                # Skip this expiration if error
                continue
        
        return best_exp_idx
    
    def _calculate_max_pain(self, calls, puts, current_price: float) -> Optional[float]:
        """
        Calculate max pain strike (where most options expire worthless).
        
        Max pain = strike where total value loss for option holders is MAXIMIZED
        (i.e., where market makers profit the most)
        
        For each strike, calculate:
        - Call pain = sum of (strike_price - call_strike) * call_OI for ITM calls
        - Put pain = sum of (put_strike - strike_price) * put_OI for ITM puts
        - Total pain = call_pain + put_pain
        
        Max pain is the strike where total pain is MINIMIZED (least payout)
        """
        try:
            # Get all unique strikes within reasonable range of current price
            # Filter to +/- 10% of current price for relevance
            min_strike = current_price * 0.90
            max_strike = current_price * 1.10
            
            relevant_strikes = sorted([
                s for s in set(calls['strike'].tolist() + puts['strike'].tolist())
                if min_strike <= s <= max_strike
            ])
            
            if not relevant_strikes:
                # Fall back to all strikes if no relevant ones
                relevant_strikes = sorted(set(calls['strike'].tolist() + puts['strike'].tolist()))
            
            if not relevant_strikes:
                return None
            
            # For each potential settlement price, calculate total option value
            min_pain = float('inf')
            max_pain_strike = current_price
            
            for settlement in relevant_strikes:
                pain = 0
                
                # Calculate call value at this settlement price
                # Call is ITM if settlement > strike
                for _, call in calls.iterrows():
                    oi = call['openInterest']
                    if pd.isna(oi) or oi <= 0:
                        continue
                    if settlement > call['strike']:
                        # Call is ITM - has intrinsic value (pain for MM)
                        pain += (settlement - call['strike']) * oi
                
                # Calculate put value at this settlement price
                # Put is ITM if settlement < strike
                for _, put in puts.iterrows():
                    oi = put['openInterest']
                    if pd.isna(oi) or oi <= 0:
                        continue
                    if settlement < put['strike']:
                        # Put is ITM - has intrinsic value (pain for MM)
                        pain += (put['strike'] - settlement) * oi
                
                if pain < min_pain:
                    min_pain = pain
                    max_pain_strike = settlement
            
            return max_pain_strike
            
        except Exception as e:
            logger.error(f"Error calculating max pain: {e}")
            return None
    
    def _calculate_score(self, pc_ratio: float, distance_pct: float, 
                         call_oi: int, put_oi: int, direction: str) -> float:
        """
        Calculate gamma signal score (0-100).
        
        Components:
        - P/C ratio deviation (40 pts): How far from neutral
        - Distance to max pain (30 pts): Larger distance = stronger pull
        - OI concentration (30 pts): Higher OI = more dealer hedging
        """
        score = 0
        
        # P/C ratio score (40 pts)
        if direction == 'UP':
            # Lower P/C = stronger bullish signal
            pc_score = min((self.MIN_PC_FOR_BULLISH - pc_ratio) / self.MIN_PC_FOR_BULLISH * 100, 100)
        else:
            # Higher P/C = stronger bearish signal
            pc_score = min((pc_ratio - self.MAX_PC_FOR_BEARISH) / self.MAX_PC_FOR_BEARISH * 100, 100)
        
        score += max(pc_score, 0) * (self.PC_WEIGHT / 100)
        
        # Distance to max pain score (30 pts)
        # More distance = stronger pull toward max pain
        distance_score = min(abs(distance_pct) * 20, 100)  # 5% distance = max score
        score += distance_score * (self.DISTANCE_WEIGHT / 100)
        
        # OI concentration score (30 pts)
        # Higher total OI = more dealer hedging = stronger signal
        total_oi = call_oi + put_oi
        # Assume 500k OI is "high" for SPY
        oi_score = min(total_oi / 500000 * 100, 100)
        score += oi_score * (self.OI_WEIGHT / 100)
        
        return score


# ==================== STANDALONE TEST ====================

if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    
    print("\n" + "="*60)
    print("üé≤ GAMMA TRACKER TEST")
    print("="*60)
    
    tracker = GammaTracker()
    
    # Test with SPY and QQQ
    test_symbols = ['SPY', 'QQQ']
    
    for symbol in test_symbols:
        print(f"\n{'='*40}")
        print(f"Testing {symbol}")
        print('='*40)
        
        signal = tracker.analyze(symbol)
        
        if signal:
            print(f"\n‚úÖ GAMMA SIGNAL FOUND!")
            print(f"   Direction: {signal.direction}")
            print(f"   Score: {signal.score:.1f}/100")
            print(f"   P/C Ratio: {signal.put_call_ratio:.2f}")
            print(f"   Max Pain: ${signal.max_pain:.2f}")
            print(f"   Distance: {signal.max_pain_distance_pct:+.2f}%")
            print(f"   Action: {signal.action}")
            print(f"   Entry: ${signal.entry_price:.2f}")
            print(f"   Target: ${signal.target_price:.2f}")
            print(f"   Stop: ${signal.stop_price:.2f}")
            print(f"   R/R: {signal.risk_reward_ratio:.1f}:1")
            print(f"   Expiration: {signal.expiration}")
            print(f"   Reasoning:")
            for r in signal.reasoning:
                print(f"      - {r}")
        else:
            print(f"\n‚ùå No gamma signal for {symbol}")
    
    print("\n" + "="*60)
    print("Test complete!")
    print("="*60)

