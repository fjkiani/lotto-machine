"""
ðŸ” OPPORTUNITY SCANNER
Scans market for high-potential exploitation opportunities
"""

from dataclasses import dataclass
from datetime import datetime
from typing import List, Dict, Optional
import logging

logger = logging.getLogger(__name__)


@dataclass
class Opportunity:
    """Represents a trading opportunity"""
    symbol: str
    score: float  # 0-100 composite score
    reasons: List[str]
    squeeze_score: Optional[float] = None
    gamma_score: Optional[float] = None
    dp_activity: Optional[float] = None
    short_interest: Optional[float] = None
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()


class OpportunityScanner:
    """
    Scans market for high-potential exploitation opportunities
    
    Uses:
    - Stock Screener API (high flow tickers)
    - Short Interest rankings
    - DP activity rankings
    - Options activity
    """
    
    def __init__(self, api_client):
        """
        Initialize scanner with API client.
        
        Args:
            api_client: UltimateChartExchangeClient instance
        """
        self.client = api_client
    
    def scan_market(self, min_score: float = 60, max_results: int = 20) -> List[Opportunity]:
        """
        Scan entire market for opportunities
        
        Args:
            min_score: Minimum composite score (0-100)
            max_results: Maximum number of results to return
        
        Returns:
            List of Opportunity objects sorted by score (highest first)
        """
        opportunities = []
        
        try:
            # Step 1: Get screener results
            screener_results = self.client.get_stock_screener(
                min_price=10.0,
                min_volume=1_000_000
            )
            
            if not screener_results:
                logger.warning("âš ï¸ No screener results found")
                return opportunities
            
            # Step 2: Score each ticker
            for ticker_data in screener_results:
                symbol = ticker_data.get('display', ticker_data.get('symbol', ''))
                if not symbol:
                    continue
                
                opportunity = self._score_ticker(symbol, ticker_data)
                if opportunity and opportunity.score >= min_score:
                    opportunities.append(opportunity)
            
            # Step 3: Sort by score (highest first)
            opportunities.sort(key=lambda x: x.score, reverse=True)
            
            return opportunities[:max_results]
        
        except Exception as e:
            logger.error(f"âŒ Error scanning market: {e}")
            return opportunities
    
    def _score_ticker(self, symbol: str, screener_data: Dict) -> Optional[Opportunity]:
        """
        Score a ticker based on multiple factors
        
        Scoring:
        - Short Interest: 30 pts (max)
        - DP Activity: 25 pts (max)
        - Options Activity: 20 pts (max)
        - Volume Surge: 15 pts (max)
        - Price Momentum: 10 pts (max)
        
        Args:
            symbol: Stock ticker
            screener_data: Data from stock screener
        
        Returns:
            Opportunity object if score >= 30, None otherwise
        """
        score = 0
        reasons = []
        
        try:
            # Get short interest
            si_data = self.client.get_short_interest(symbol)
            if si_data:
                si_pct = self._extract_si_pct(si_data)
                if si_pct > 15:
                    si_score = min((si_pct / 30) * 30, 30)
                    score += si_score
                    reasons.append(f"High SI: {si_pct:.1f}%")
            
            # Get DP activity
            dp_levels = self.client.get_dark_pool_levels(symbol)
            if dp_levels and len(dp_levels) > 50:
                dp_score = min((len(dp_levels) / 200) * 25, 25)
                score += dp_score
                reasons.append(f"High DP activity: {len(dp_levels)} levels")
            
            # Get options activity (if available)
            # TODO: Add options activity scoring when data available
            
            # Volume surge (from screener data)
            volume_str = screener_data.get('reg_volume', '0')
            try:
                volume = int(float(volume_str))
                if volume > 10_000_000:  # High volume
                    volume_score = min((volume / 50_000_000) * 15, 15)
                    score += volume_score
                    reasons.append(f"High volume: {volume:,.0f}")
            except (ValueError, TypeError):
                pass
            
            # Price momentum (from screener data)
            price_str = screener_data.get('reg_price', '0')
            try:
                price = float(price_str)
                if price > 0:
                    # Simple momentum proxy - could be enhanced
                    momentum_score = 5  # Base score for being in screener
                    score += momentum_score
                    reasons.append(f"Price: ${price:.2f}")
            except (ValueError, TypeError):
                pass
            
            if score < 30:
                return None  # Too low score
            
            return Opportunity(
                symbol=symbol,
                score=score,
                reasons=reasons,
                short_interest=si_pct if si_data else None,
                dp_activity=len(dp_levels) if dp_levels else None,
                timestamp=datetime.now()
            )
        
        except Exception as e:
            logger.debug(f"Error scoring {symbol}: {e}")
            return None
    
    def _extract_si_pct(self, si_data: List[Dict]) -> float:
        """Extract short interest percentage"""
        if isinstance(si_data, list) and len(si_data) > 0:
            return float(si_data[0].get('short_interest', 0))
        return 0.0
    
    def scan_with_squeeze_detector(self, squeeze_detector, min_score: float = 50) -> List[Opportunity]:
        """
        Scan market and run squeeze detector on each candidate
        
        Args:
            squeeze_detector: SqueezeDetector instance
            min_score: Minimum squeeze score threshold
        
        Returns:
            List of opportunities that pass squeeze detector threshold
        """
        opportunities = []
        
        try:
            # Get screener results
            screener_results = self.client.get_stock_screener(min_price=10.0, min_volume=1_000_000)
            
            if not screener_results:
                return opportunities
            
            for ticker_data in screener_results:
                symbol = ticker_data.get('display', ticker_data.get('symbol', ''))
                if not symbol:
                    continue
                
                # Run squeeze detector
                squeeze_signal = squeeze_detector.analyze(symbol)
                
                if squeeze_signal and squeeze_signal.score >= min_score:
                    opportunities.append(Opportunity(
                        symbol=symbol,
                        score=squeeze_signal.score,
                        reasons=[f"Squeeze score: {squeeze_signal.score:.0f}/100"],
                        squeeze_score=squeeze_signal.score,
                        short_interest=squeeze_signal.short_interest_pct,
                        timestamp=datetime.now()
                    ))
            
            # Sort by score
            opportunities.sort(key=lambda x: x.score, reverse=True)
            
            return opportunities
        
        except Exception as e:
            logger.error(f"âŒ Error scanning with squeeze detector: {e}")
            return opportunities
    
    def get_high_short_interest_stocks(self) -> List[str]:
        """
        ðŸŽ¯ DYNAMIC DISCOVERY: Get stocks with high short interest
        
        Combines multiple sources:
        1. Known high-SI stocks (curated list, updated weekly)
        2. API scan for stocks with SI > 15%
        3. Recent meme stocks and WSB favorites
        
        Returns:
            List of ticker symbols with high short interest
        """
        high_si_stocks = set()
        
        # SOURCE 1: Known high-SI stocks (curated list)
        # These are stocks that historically have high short interest
        # Updated periodically based on market conditions
        KNOWN_HIGH_SI = [
            # Meme stocks
            'GME', 'AMC', 'BBBY', 'BB', 'NOK', 'KOSS',
            # EV/Clean Energy (often heavily shorted)
            'LCID', 'RIVN', 'NIO', 'FFIE', 'GOEV', 'RIDE', 'WKHS',
            # Crypto/Mining
            'MARA', 'RIOT', 'HUT', 'BITF', 'COIN',
            # Biotech (volatile, often shorted)
            'SAVA', 'CLOV', 'WISH', 'WKHS',
            # Tech/Growth (high SI periods)
            'PLTR', 'SOFI', 'UPST', 'AFRM',
            # Recent additions (check SI periodically)
            'CVNA', 'BYND', 'SPCE', 'PLUG', 'FCEL'
        ]
        high_si_stocks.update(KNOWN_HIGH_SI)
        
        # SOURCE 2: Scan API for stocks with SI > 15%
        try:
            screener_results = self.client.get_stock_screener(min_price=5.0, min_volume=500_000)
            if screener_results:
                for ticker_data in screener_results:
                    symbol = ticker_data.get('display', ticker_data.get('symbol', ''))
                    if not symbol:
                        continue
                    
                    # Check short interest
                    si_data = self.client.get_short_interest(symbol)
                    if si_data:
                        si_pct = self._extract_si_pct(si_data)
                        if si_pct > 15:  # High SI threshold
                            high_si_stocks.add(symbol)
                            logger.info(f"   ðŸ“¡ Discovered high SI: {symbol} ({si_pct:.1f}%)")
        except Exception as e:
            logger.debug(f"SI scan error: {e}")
        
        return list(high_si_stocks)
    
    def scan_for_squeeze_candidates(self, squeeze_detector, min_score: float = 55) -> List[Opportunity]:
        """
        ðŸ”¥ DYNAMIC SQUEEZE DISCOVERY
        
        Scans ALL high-SI stocks (not just screener results) for squeeze setups.
        This is the main method for finding squeeze opportunities dynamically.
        
        Args:
            squeeze_detector: SqueezeDetector instance
            min_score: Minimum squeeze score threshold
        
        Returns:
            List of squeeze opportunities sorted by score
        """
        opportunities = []
        
        try:
            # Get all high SI stocks
            high_si_stocks = self.get_high_short_interest_stocks()
            logger.info(f"ðŸ” Scanning {len(high_si_stocks)} high-SI stocks for squeeze setups...")
            
            for symbol in high_si_stocks:
                try:
                    squeeze_signal = squeeze_detector.analyze(symbol)
                    
                    if squeeze_signal and squeeze_signal.score >= min_score:
                        opportunities.append(Opportunity(
                            symbol=symbol,
                            score=squeeze_signal.score,
                            reasons=[
                                f"Squeeze score: {squeeze_signal.score:.0f}/100",
                                f"SI: {squeeze_signal.short_interest_pct:.1f}%",
                                f"Borrow: {squeeze_signal.borrow_fee_pct:.1f}%"
                            ],
                            squeeze_score=squeeze_signal.score,
                            short_interest=squeeze_signal.short_interest_pct,
                            timestamp=datetime.now()
                        ))
                        logger.info(f"   ðŸ”¥ Found squeeze: {symbol} (Score: {squeeze_signal.score:.0f})")
                except Exception as e:
                    logger.debug(f"Error analyzing {symbol}: {e}")
            
            # Sort by score
            opportunities.sort(key=lambda x: x.score, reverse=True)
            
            return opportunities
        
        except Exception as e:
            logger.error(f"âŒ Error in squeeze scan: {e}")
            return opportunities
    
    def get_daily_rankings(self) -> Dict[str, List[Opportunity]]:
        """
        Get daily rankings by category
        
        Returns:
            Dictionary with keys:
            - 'squeeze_candidates': List of squeeze opportunities
            - 'gamma_opportunities': List of gamma opportunities (future)
            - 'dp_active': List of high DP activity tickers
            - 'high_flow': List of high flow tickers
        """
        rankings = {
            'squeeze_candidates': [],
            'gamma_opportunities': [],
            'dp_active': [],
            'high_flow': []
        }
        
        # Scan market
        all_opportunities = self.scan_market(min_score=40, max_results=100)
        
        # Categorize
        for opp in all_opportunities:
            if opp.squeeze_score and opp.squeeze_score >= 50:
                rankings['squeeze_candidates'].append(opp)
            
            if opp.dp_activity and opp.dp_activity > 50:
                rankings['dp_active'].append(opp)
            
            # High flow = high volume
            if opp.score >= 60:
                rankings['high_flow'].append(opp)
        
        # Sort each category
        for key in rankings:
            rankings[key].sort(key=lambda x: x.score, reverse=True)
        
        return rankings

