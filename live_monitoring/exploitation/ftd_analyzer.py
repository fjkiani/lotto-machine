"""
üìà FTD ANALYZER - Failure to Deliver Exploitation Module

Exploits the T+35 settlement cycle for FTD spikes:
- Detects FTD accumulation patterns
- Predicts forced covering events
- Identifies settlement cycle pressure points

Key Concepts:
- T+2: Trade settlement (shares must be delivered)
- T+35: Forced buy-in deadline for FTDs
- FTD Spike: Sudden increase in FTDs signals delivery failure
- Forced Covering: When shorts must cover due to FTD accumulation

Signal Logic:
1. FTD ACCUMULATION: FTDs building up ‚Üí pressure mounting
2. T+35 WINDOW: Approaching forced buy-in ‚Üí potential squeeze
3. FTD SPIKE: Sudden FTD increase ‚Üí delivery failure detected
4. COVERING PRESSURE: High FTDs + Rising price ‚Üí shorts trapped

NO MOCK DATA. Returns None if API fails.
"""

import logging
import sqlite3
import json
import os
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any
from dataclasses import dataclass, asdict

logger = logging.getLogger(__name__)

# Database path for FTD signals
FTD_SIGNALS_DB = "data/ftd_signals.db"


@dataclass
class FTDSignal:
    """FTD-based trading signal"""
    symbol: str
    timestamp: datetime
    signal_type: str  # "ACCUMULATION", "T35_WINDOW", "SPIKE", "COVERING_PRESSURE"
    score: float  # 0-100
    
    # Component scores
    ftd_volume_score: float
    ftd_trend_score: float
    t35_proximity_score: float
    price_momentum_score: float
    
    # Raw data
    current_ftd: int
    avg_ftd: float
    ftd_spike_ratio: float
    days_to_t35: int
    ftd_as_pct_of_volume: float
    
    # Trade setup
    action: str  # "LONG" for FTD-based plays
    entry_price: float
    stop_price: float
    target_price: float
    risk_reward_ratio: float
    
    # Context
    reasoning: List[str]
    warnings: List[str]
    ftd_history: List[Dict]  # Last N days of FTD data


class FTDAnalyzer:
    """
    Analyzes Failure to Deliver data for trading signals.
    
    The T+35 settlement cycle creates predictable pressure points:
    - FTDs accumulate when shorts fail to deliver
    - After T+35, forced buy-ins occur
    - This creates buying pressure and potential squeezes
    """
    
    # Signal threshold
    SIGNAL_THRESHOLD = 60  # Minimum score to generate signal
    
    # Score weights (max points) - Total = 100
    MAX_FTD_VOLUME_SCORE = 35    # High FTD volume relative to avg
    MAX_FTD_TREND_SCORE = 25     # FTDs trending up
    MAX_T35_PROXIMITY_SCORE = 25  # Close to T+35 deadline
    MAX_MOMENTUM_SCORE = 15       # Price momentum (rising = better)
    
    # FTD thresholds
    FTD_SPIKE_THRESHOLD = 2.0     # 2x avg = spike
    FTD_SIGNIFICANT_THRESHOLD = 1.5  # 1.5x avg = significant
    FTD_AS_PCT_VOLUME_THRESHOLD = 0.5  # FTDs > 0.5% of daily volume is significant
    
    # T+35 window
    T35_CRITICAL_DAYS = 5  # Days before T+35 = critical window
    T35_WARNING_DAYS = 10  # Days before T+35 = warning zone
    
    # Trade parameters
    DEFAULT_TARGET_PCT = 0.08  # 8% target (FTD plays can run)
    MIN_STOP_PCT = 0.02  # 2% minimum stop
    MIN_RR_RATIO = 2.0  # Minimum 2:1 R/R
    
    def __init__(self, client, db_path: str = FTD_SIGNALS_DB):
        """
        Initialize FTD Analyzer.
        
        Args:
            client: UltimateChartExchangeClient instance
            db_path: Path to SQLite database for signal storage
        """
        self.client = client
        self.db_path = db_path
        self._init_database()
    
    def _init_database(self):
        """Initialize SQLite database for storing FTD signals."""
        try:
            os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
            
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Create FTD signals table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS ftd_signals (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT NOT NULL,
                    symbol TEXT NOT NULL,
                    signal_type TEXT NOT NULL,
                    score REAL NOT NULL,
                    ftd_volume_score REAL,
                    ftd_trend_score REAL,
                    t35_proximity_score REAL,
                    price_momentum_score REAL,
                    current_ftd INTEGER,
                    avg_ftd REAL,
                    ftd_spike_ratio REAL,
                    days_to_t35 INTEGER,
                    ftd_as_pct_of_volume REAL,
                    action TEXT,
                    entry_price REAL,
                    stop_price REAL,
                    target_price REAL,
                    risk_reward_ratio REAL,
                    reasoning TEXT,
                    warnings TEXT,
                    ftd_history TEXT,
                    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Create FTD raw data table for backtesting
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS ftd_raw_data (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT NOT NULL,
                    symbol TEXT NOT NULL,
                    ftd_date TEXT NOT NULL,
                    quantity INTEGER,
                    price REAL,
                    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Create T+35 calendar table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS ftd_t35_calendar (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT NOT NULL,
                    symbol TEXT NOT NULL,
                    ftd_date TEXT NOT NULL,
                    t35_date TEXT NOT NULL,
                    days_until INTEGER,
                    ftd_quantity INTEGER,
                    ftd_price REAL,
                    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Create indexes
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_ftd_signals_timestamp ON ftd_signals(timestamp)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_ftd_signals_symbol ON ftd_signals(symbol)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_ftd_raw_symbol ON ftd_raw_data(symbol)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_ftd_t35_symbol ON ftd_t35_calendar(symbol)")
            
            conn.commit()
            conn.close()
            logger.debug(f"   ‚úÖ FTD database initialized: {self.db_path}")
        except Exception as e:
            logger.warning(f"   ‚ö†Ô∏è Failed to initialize FTD database: {e}")
    
    def _log_signal_to_db(self, signal: 'FTDSignal'):
        """Log FTD signal to database for backtesting."""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("""
                INSERT INTO ftd_signals (
                    timestamp, symbol, signal_type, score,
                    ftd_volume_score, ftd_trend_score, t35_proximity_score, price_momentum_score,
                    current_ftd, avg_ftd, ftd_spike_ratio, days_to_t35, ftd_as_pct_of_volume,
                    action, entry_price, stop_price, target_price, risk_reward_ratio,
                    reasoning, warnings, ftd_history
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                signal.timestamp.isoformat(),
                signal.symbol,
                signal.signal_type,
                signal.score,
                signal.ftd_volume_score,
                signal.ftd_trend_score,
                signal.t35_proximity_score,
                signal.price_momentum_score,
                signal.current_ftd,
                signal.avg_ftd,
                signal.ftd_spike_ratio,
                signal.days_to_t35,
                signal.ftd_as_pct_of_volume,
                signal.action,
                signal.entry_price,
                signal.stop_price,
                signal.target_price,
                signal.risk_reward_ratio,
                json.dumps(signal.reasoning),
                json.dumps(signal.warnings),
                json.dumps(signal.ftd_history)
            ))
            
            conn.commit()
            conn.close()
            logger.debug(f"   üìù FTD signal logged to database: {signal.symbol} {signal.signal_type}")
        except Exception as e:
            logger.debug(f"   ‚ö†Ô∏è Failed to log FTD signal to database: {e}")
    
    def _log_raw_ftd_data(self, symbol: str, ftd_data: List[Dict]):
        """Log raw FTD data for backtesting."""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            timestamp = datetime.now().isoformat()
            
            for entry in ftd_data[:30]:  # Store last 30 days
                cursor.execute("""
                    INSERT INTO ftd_raw_data (timestamp, symbol, ftd_date, quantity, price)
                    VALUES (?, ?, ?, ?, ?)
                """, (
                    timestamp,
                    symbol,
                    entry.get('date', ''),
                    entry.get('quantity', 0),
                    entry.get('price', 0)
                ))
            
            conn.commit()
            conn.close()
            logger.debug(f"   üìù Raw FTD data logged: {symbol} ({len(ftd_data)} records)")
        except Exception as e:
            logger.debug(f"   ‚ö†Ô∏è Failed to log raw FTD data: {e}")
    
    def get_historical_signals(self, symbol: Optional[str] = None, days: int = 30) -> List[Dict]:
        """Retrieve historical FTD signals for backtesting."""
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            if symbol:
                cursor.execute("""
                    SELECT * FROM ftd_signals 
                    WHERE symbol = ? AND timestamp >= datetime('now', ?)
                    ORDER BY timestamp DESC
                """, (symbol, f'-{days} days'))
            else:
                cursor.execute("""
                    SELECT * FROM ftd_signals 
                    WHERE timestamp >= datetime('now', ?)
                    ORDER BY timestamp DESC
                """, (f'-{days} days',))
            
            rows = cursor.fetchall()
            conn.close()
            
            return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"Failed to retrieve historical signals: {e}")
            return []
    
    def analyze(self, symbol: str, current_price: Optional[float] = None,
                date: Optional[str] = None) -> Optional[FTDSignal]:
        """
        Analyze FTD data for trading signals.
        
        Args:
            symbol: Stock ticker
            current_price: Current stock price (fetched if not provided)
            date: Analysis date (defaults to today)
        
        Returns:
            FTDSignal if criteria met, None otherwise
        """
        logger.info(f"üìà Analyzing FTDs for {symbol}...")
        
        date_str = date or datetime.now().strftime('%Y-%m-%d')
        
        # Step 1: Fetch FTD data (last 60 days for trend analysis)
        ftd_data = self._fetch_ftd_data(symbol, lookback_days=60)
        if not ftd_data or len(ftd_data) < 5:
            logger.warning(f"   ‚ö†Ô∏è Insufficient FTD data for {symbol}")
            return None
        
        # Get current price if not provided
        if current_price is None:
            current_price = self._get_current_price(symbol)
            if current_price is None:
                logger.warning(f"   ‚ö†Ô∏è Failed to get price for {symbol}")
                return None
        
        # Get average daily volume for context
        avg_volume = self._get_avg_daily_volume(symbol)
        
        # Step 2: Calculate FTD metrics
        metrics = self._calculate_ftd_metrics(ftd_data, avg_volume)
        
        # Check if we have meaningful FTD data
        if not metrics.get('has_ftd_data', False):
            logger.info(f"   ‚ö†Ô∏è No non-zero FTD data for {symbol} - FTDs may be clean")
            # Still return a signal if other factors are interesting
            # but with reduced confidence
        
        # Step 3: Calculate component scores
        ftd_volume_score = self._calculate_ftd_volume_score(metrics)
        ftd_trend_score = self._calculate_ftd_trend_score(metrics)
        t35_proximity_score = self._calculate_t35_score(metrics)
        momentum_score = self._calculate_momentum_score(symbol, current_price)
        
        total_score = ftd_volume_score + ftd_trend_score + t35_proximity_score + momentum_score
        
        logger.info(f"   üìä {symbol} FTD Score: {total_score:.1f}/100")
        logger.info(f"      FTD Volume: {metrics['current_ftd']:,} ({ftd_volume_score:.1f} pts)")
        logger.info(f"      FTD Trend: {metrics['ftd_trend']:.2f}x ({ftd_trend_score:.1f} pts)")
        logger.info(f"      T+35 Days: {metrics['days_to_t35']} ({t35_proximity_score:.1f} pts)")
        logger.info(f"      Momentum: ({momentum_score:.1f} pts)")
        
        # Step 4: Check threshold
        if total_score < self.SIGNAL_THRESHOLD:
            logger.info(f"   ‚ùå Score {total_score:.1f} < {self.SIGNAL_THRESHOLD} threshold - no signal")
            return None
        
        # Step 5: Determine signal type
        signal_type = self._determine_signal_type(metrics, total_score)
        
        # Step 6: Calculate trade setup
        entry = current_price
        stop = entry * (1 - self.MIN_STOP_PCT)
        
        # Adjust target based on signal strength
        target_pct = self.DEFAULT_TARGET_PCT
        if total_score >= 80:
            target_pct = 0.12  # 12% for high conviction
        elif total_score >= 70:
            target_pct = 0.10  # 10% for medium-high
        
        target = entry * (1 + target_pct)
        
        # Calculate R/R
        risk = entry - stop
        reward = target - entry
        rr_ratio = reward / risk if risk > 0 else 0
        
        # Enforce minimum R/R
        if rr_ratio < self.MIN_RR_RATIO:
            target = entry + (risk * self.MIN_RR_RATIO)
            rr_ratio = self.MIN_RR_RATIO
        
        # Step 7: Build reasoning and warnings
        reasoning = []
        warnings = []
        
        if metrics['ftd_spike_ratio'] >= self.FTD_SPIKE_THRESHOLD:
            reasoning.append(f"FTD SPIKE: {metrics['ftd_spike_ratio']:.1f}x above average")
        
        if metrics['ftd_trend'] > 1.2:
            reasoning.append(f"FTDs TRENDING UP: {metrics['ftd_trend']:.1f}x week-over-week")
        
        if metrics['days_to_t35'] <= self.T35_CRITICAL_DAYS:
            reasoning.append(f"T+35 CRITICAL: Only {metrics['days_to_t35']} days to forced buy-in")
        elif metrics['days_to_t35'] <= self.T35_WARNING_DAYS:
            reasoning.append(f"T+35 WARNING: {metrics['days_to_t35']} days to deadline")
        
        if metrics['ftd_as_pct_volume'] >= self.FTD_AS_PCT_VOLUME_THRESHOLD:
            reasoning.append(f"HIGH FTD/VOLUME: {metrics['ftd_as_pct_volume']:.2f}% of daily volume")
        
        # Warnings
        if metrics['current_ftd'] < 100000:
            warnings.append(f"Low absolute FTD count ({metrics['current_ftd']:,})")
        
        if metrics['ftd_trend'] < 1.0:
            warnings.append(f"FTDs declining ({metrics['ftd_trend']:.2f}x trend)")
        
        if avg_volume and avg_volume < 1000000:
            warnings.append(f"Low volume stock - FTD impact may be limited")
        
        logger.info(f"   ‚úÖ FTD SIGNAL: {signal_type} | Score: {total_score:.1f}")
        
        # Log raw FTD data for backtesting
        self._log_raw_ftd_data(symbol, ftd_data)
        
        signal = FTDSignal(
            symbol=symbol,
            timestamp=datetime.now(),
            signal_type=signal_type,
            score=total_score,
            ftd_volume_score=ftd_volume_score,
            ftd_trend_score=ftd_trend_score,
            t35_proximity_score=t35_proximity_score,
            price_momentum_score=momentum_score,
            current_ftd=metrics['current_ftd'],
            avg_ftd=metrics['avg_ftd'],
            ftd_spike_ratio=metrics['ftd_spike_ratio'],
            days_to_t35=metrics['days_to_t35'],
            ftd_as_pct_of_volume=metrics['ftd_as_pct_volume'],
            action="LONG",
            entry_price=entry,
            stop_price=stop,
            target_price=target,
            risk_reward_ratio=rr_ratio,
            reasoning=reasoning,
            warnings=warnings,
            ftd_history=ftd_data[:10]  # Last 10 days
        )
        
        # Log signal to database for backtesting
        self._log_signal_to_db(signal)
        
        return signal
    
    def _fetch_ftd_data(self, symbol: str, lookback_days: int = 60) -> Optional[List[Dict]]:
        """Fetch FTD data for the lookback period."""
        try:
            start_date = (datetime.now() - timedelta(days=lookback_days)).strftime('%Y-%m-%d')
            data = self.client.get_failure_to_deliver(symbol, start_date=start_date)
            
            if not data:
                return None
            
            # Convert to list of dicts
            ftd_list = []
            for entry in data:
                if hasattr(entry, '__dict__'):
                    ftd_list.append({
                        'date': entry.date,
                        'quantity': entry.quantity,
                        'price': entry.price
                    })
                elif isinstance(entry, dict):
                    ftd_list.append(entry)
            
            # Sort by date (newest first)
            ftd_list.sort(key=lambda x: x.get('date', ''), reverse=True)
            
            return ftd_list
            
        except Exception as e:
            logger.error(f"Failed to fetch FTD data for {symbol}: {e}")
            return None
    
    def _get_current_price(self, symbol: str) -> Optional[float]:
        """Get current stock price."""
        try:
            import yfinance as yf
            ticker = yf.Ticker(symbol)
            hist = ticker.history(period='1d', interval='1m')
            if not hist.empty:
                return float(hist['Close'].iloc[-1])
            return None
        except Exception as e:
            logger.error(f"Failed to get price for {symbol}: {e}")
            return None
    
    def _get_avg_daily_volume(self, symbol: str) -> Optional[float]:
        """Get average daily volume (20-day)."""
        try:
            import yfinance as yf
            ticker = yf.Ticker(symbol)
            hist = ticker.history(period='1mo')
            if not hist.empty:
                return float(hist['Volume'].mean())
            return None
        except Exception as e:
            logger.debug(f"Failed to get volume for {symbol}: {e}")
            return None
    
    def _calculate_ftd_metrics(self, ftd_data: List[Dict], avg_volume: Optional[float]) -> Dict:
        """Calculate FTD metrics from historical data."""
        # Extract quantities
        quantities = []
        for entry in ftd_data:
            qty = entry.get('quantity', 0)
            try:
                quantities.append(int(qty))
            except (ValueError, TypeError):
                continue
        
        # Filter out zeros for meaningful analysis
        non_zero_quantities = [q for q in quantities if q > 0]
        
        if not quantities:
            return {
                'current_ftd': 0,
                'avg_ftd': 0,
                'ftd_spike_ratio': 0,
                'ftd_trend': 0,
                'days_to_t35': 35,
                'ftd_as_pct_volume': 0,
                'has_ftd_data': False
            }
        
        # If all zeros, return with flag
        if not non_zero_quantities:
            return {
                'current_ftd': 0,
                'avg_ftd': 0,
                'ftd_spike_ratio': 0,
                'ftd_trend': 0,
                'days_to_t35': 35,
                'ftd_as_pct_volume': 0,
                'has_ftd_data': False
            }
        
        # Use non-zero values for meaningful metrics
        current_ftd = non_zero_quantities[0] if non_zero_quantities else quantities[0] if quantities else 0
        avg_ftd = sum(non_zero_quantities) / len(non_zero_quantities) if non_zero_quantities else 0
        
        # Spike ratio (current vs avg of non-zero)
        ftd_spike_ratio = current_ftd / avg_ftd if avg_ftd > 0 else 0
        
        # Trend (last 7 non-zero days vs previous 7 non-zero days)
        recent_non_zero = non_zero_quantities[:7] if non_zero_quantities else []
        older_non_zero = non_zero_quantities[7:14] if len(non_zero_quantities) > 7 else []
        
        recent_avg = sum(recent_non_zero) / len(recent_non_zero) if recent_non_zero else 0
        older_avg = sum(older_non_zero) / len(older_non_zero) if older_non_zero else recent_avg
        ftd_trend = recent_avg / older_avg if older_avg > 0 else 1.0
        
        # Days to T+35 (estimate based on most recent FTD date)
        if ftd_data and ftd_data[0].get('date'):
            try:
                latest_date = datetime.strptime(ftd_data[0]['date'], '%Y-%m-%d')
                days_since = (datetime.now() - latest_date).days
                days_to_t35 = max(0, 35 - days_since)
            except:
                days_to_t35 = 35
        else:
            days_to_t35 = 35
        
        # FTD as percentage of volume
        ftd_as_pct_volume = (current_ftd / avg_volume * 100) if avg_volume and avg_volume > 0 else 0
        
        return {
            'current_ftd': current_ftd,
            'avg_ftd': avg_ftd,
            'ftd_spike_ratio': ftd_spike_ratio,
            'ftd_trend': ftd_trend,
            'days_to_t35': days_to_t35,
            'ftd_as_pct_volume': ftd_as_pct_volume,
            'has_ftd_data': len(non_zero_quantities) > 0,
            'non_zero_count': len(non_zero_quantities)
        }
    
    def _calculate_ftd_volume_score(self, metrics: Dict) -> float:
        """Score based on FTD volume relative to average."""
        spike_ratio = metrics['ftd_spike_ratio']
        
        if spike_ratio >= 3.0:
            return self.MAX_FTD_VOLUME_SCORE  # Max score for 3x+ spike
        elif spike_ratio >= 2.0:
            return self.MAX_FTD_VOLUME_SCORE * 0.8
        elif spike_ratio >= 1.5:
            return self.MAX_FTD_VOLUME_SCORE * 0.6
        elif spike_ratio >= 1.2:
            return self.MAX_FTD_VOLUME_SCORE * 0.4
        else:
            return self.MAX_FTD_VOLUME_SCORE * (spike_ratio / 2.0) * 0.4
    
    def _calculate_ftd_trend_score(self, metrics: Dict) -> float:
        """Score based on FTD trend (rising = higher score)."""
        trend = metrics['ftd_trend']
        
        if trend >= 2.0:
            return self.MAX_FTD_TREND_SCORE  # Max for 2x+ week-over-week
        elif trend >= 1.5:
            return self.MAX_FTD_TREND_SCORE * 0.8
        elif trend >= 1.2:
            return self.MAX_FTD_TREND_SCORE * 0.6
        elif trend >= 1.0:
            return self.MAX_FTD_TREND_SCORE * 0.4
        else:
            return self.MAX_FTD_TREND_SCORE * 0.2  # Declining FTDs
    
    def _calculate_t35_score(self, metrics: Dict) -> float:
        """Score based on proximity to T+35 deadline."""
        days = metrics['days_to_t35']
        
        if days <= 3:
            return self.MAX_T35_PROXIMITY_SCORE  # Max for imminent deadline
        elif days <= 5:
            return self.MAX_T35_PROXIMITY_SCORE * 0.9
        elif days <= 10:
            return self.MAX_T35_PROXIMITY_SCORE * 0.7
        elif days <= 15:
            return self.MAX_T35_PROXIMITY_SCORE * 0.5
        elif days <= 25:
            return self.MAX_T35_PROXIMITY_SCORE * 0.3
        else:
            return self.MAX_T35_PROXIMITY_SCORE * 0.1
    
    def _calculate_momentum_score(self, symbol: str, current_price: float) -> float:
        """Score based on price momentum (rising price = higher score)."""
        try:
            import yfinance as yf
            ticker = yf.Ticker(symbol)
            hist = ticker.history(period='5d')
            
            if hist.empty or len(hist) < 2:
                return self.MAX_MOMENTUM_SCORE * 0.5  # Neutral
            
            # Calculate 5-day return
            start_price = float(hist['Close'].iloc[0])
            five_day_return = (current_price - start_price) / start_price
            
            if five_day_return >= 0.05:  # +5% or more
                return self.MAX_MOMENTUM_SCORE
            elif five_day_return >= 0.02:  # +2% to +5%
                return self.MAX_MOMENTUM_SCORE * 0.8
            elif five_day_return >= 0:  # 0% to +2%
                return self.MAX_MOMENTUM_SCORE * 0.6
            elif five_day_return >= -0.02:  # -2% to 0%
                return self.MAX_MOMENTUM_SCORE * 0.4
            else:  # < -2%
                return self.MAX_MOMENTUM_SCORE * 0.2
                
        except Exception as e:
            logger.debug(f"Failed to calculate momentum for {symbol}: {e}")
            return self.MAX_MOMENTUM_SCORE * 0.5  # Neutral
    
    def _determine_signal_type(self, metrics: Dict, score: float) -> str:
        """Determine the type of FTD signal."""
        days = metrics['days_to_t35']
        spike = metrics['ftd_spike_ratio']
        trend = metrics['ftd_trend']
        
        # Priority order: T35_WINDOW > SPIKE > COVERING_PRESSURE > ACCUMULATION
        if days <= self.T35_CRITICAL_DAYS:
            return "T35_WINDOW"
        elif spike >= self.FTD_SPIKE_THRESHOLD:
            return "SPIKE"
        elif trend >= 1.5 and spike >= 1.5:
            return "COVERING_PRESSURE"
        else:
            return "ACCUMULATION"
    
    def get_ftd_candidates(self, symbols: List[str], min_score: float = 50) -> List[FTDSignal]:
        """
        Scan multiple symbols for FTD opportunities.
        
        Args:
            symbols: List of stock tickers
            min_score: Minimum score threshold
        
        Returns:
            List of FTDSignal objects sorted by score
        """
        signals = []
        
        for symbol in symbols:
            try:
                signal = self.analyze(symbol)
                if signal and signal.score >= min_score:
                    signals.append(signal)
            except Exception as e:
                logger.debug(f"Error analyzing {symbol}: {e}")
                continue
        
        # Sort by score (highest first)
        signals.sort(key=lambda x: x.score, reverse=True)
        
        return signals
    
    def get_t35_calendar(self, symbols: List[str]) -> List[Dict]:
        """
        Get T+35 calendar for multiple symbols.
        
        Returns list of upcoming T+35 deadlines sorted by date.
        """
        calendar = []
        
        for symbol in symbols:
            try:
                ftd_data = self._fetch_ftd_data(symbol, lookback_days=40)
                if not ftd_data:
                    continue
                
                # Find dates with significant FTDs
                for entry in ftd_data:
                    qty = entry.get('quantity', 0)
                    if qty > 50000:  # Significant FTD
                        try:
                            ftd_date = datetime.strptime(entry['date'], '%Y-%m-%d')
                            t35_date = ftd_date + timedelta(days=35)
                            days_until = (t35_date - datetime.now()).days
                            
                            if days_until > 0:  # Only future deadlines
                                calendar.append({
                                    'symbol': symbol,
                                    'ftd_date': entry['date'],
                                    't35_date': t35_date.strftime('%Y-%m-%d'),
                                    'days_until': days_until,
                                    'ftd_quantity': qty,
                                    'ftd_price': entry.get('price', 0)
                                })
                        except:
                            continue
                            
            except Exception as e:
                logger.debug(f"Error getting T+35 for {symbol}: {e}")
                continue
        
        # Sort by days until T+35
        calendar.sort(key=lambda x: x['days_until'])
        
        return calendar


# ==================== TEST ====================
if __name__ == "__main__":
    import os
    from dotenv import load_dotenv
    
    load_dotenv()
    
    api_key = os.getenv('CHARTEXCHANGE_API_KEY') or os.getenv('CHART_EXCHANGE_API_KEY')
    
    if not api_key:
        print("‚ùå No API key found!")
        exit(1)
    
    from core.data.ultimate_chartexchange_client import UltimateChartExchangeClient
    
    client = UltimateChartExchangeClient(api_key, tier=3)
    analyzer = FTDAnalyzer(client)
    
    # Test on known squeeze candidates
    test_symbols = ['GME', 'AMC', 'LCID', 'RIVN', 'BBBY']
    
    print("=" * 60)
    print("üìà FTD ANALYZER TEST")
    print("=" * 60)
    
    for symbol in test_symbols:
        print(f"\nüîç Testing {symbol}...")
        signal = analyzer.analyze(symbol)
        
        if signal:
            print(f"\n‚úÖ FTD SIGNAL: {signal.symbol}")
            print(f"   Type: {signal.signal_type}")
            print(f"   Score: {signal.score:.1f}/100")
            print(f"   Current FTD: {signal.current_ftd:,}")
            print(f"   Spike Ratio: {signal.ftd_spike_ratio:.2f}x")
            print(f"   Days to T+35: {signal.days_to_t35}")
            print(f"   Entry: ${signal.entry_price:.2f}")
            print(f"   Stop: ${signal.stop_price:.2f}")
            print(f"   Target: ${signal.target_price:.2f}")
            print(f"   R/R: {signal.risk_reward_ratio:.1f}:1")
            print(f"   Reasoning: {signal.reasoning}")
            if signal.warnings:
                print(f"   Warnings: {signal.warnings}")
        else:
            print(f"   ‚ùå No FTD signal for {symbol}")
    
    # Test T+35 calendar
    print("\n" + "=" * 60)
    print("üìÖ T+35 CALENDAR")
    print("=" * 60)
    
    calendar = analyzer.get_t35_calendar(test_symbols)
    for event in calendar[:10]:
        print(f"   {event['symbol']}: T+35 on {event['t35_date']} ({event['days_until']} days) - {event['ftd_quantity']:,} FTDs")

