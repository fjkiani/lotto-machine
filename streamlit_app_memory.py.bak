import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
import json
import os
import logging
import sqlite3
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import seaborn as sns
from dotenv import load_dotenv

from src.llm.memory_enhanced_analysis import MemoryEnhancedAnalysis
from src.analysis.technical_indicators_storage import TechnicalIndicatorsStorage
from src.analysis.trend_analysis_storage import TrendAnalysisStorage

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()

# Initialize session state
if 'memory_analyzer' not in st.session_state:
    st.session_state.memory_analyzer = MemoryEnhancedAnalysis()

if 'tech_storage' not in st.session_state:
    st.session_state.tech_storage = TechnicalIndicatorsStorage()

if 'trend_storage' not in st.session_state:
    st.session_state.trend_storage = TrendAnalysisStorage()

if 'analysis_history' not in st.session_state:
    st.session_state.analysis_history = {}

if 'current_analysis' not in st.session_state:
    st.session_state.current_analysis = None

if 'current_ticker' not in st.session_state:
    st.session_state.current_ticker = None

if 'analysis_id' not in st.session_state:
    st.session_state.analysis_id = None

if 'indicator_data' not in st.session_state:
    st.session_state.indicator_data = {}

if 'trend_analysis_id' not in st.session_state:
    st.session_state.trend_analysis_id = None

def run_analysis(ticker, analysis_type, risk_tolerance):
    """
    Run memory-enhanced analysis for a ticker
    
    Args:
        ticker: Ticker symbol
        analysis_type: Type of analysis
        risk_tolerance: Risk tolerance level
        
    Returns:
        Analysis results
    """
    try:
        # Run the analysis
        result = st.session_state.memory_analyzer.analyze_ticker_with_memory(
            ticker=ticker,
            analysis_type=analysis_type,
            risk_tolerance=risk_tolerance
        )
        
        # Store the result in session state
        st.session_state.current_analysis = result
        st.session_state.current_ticker = ticker
        
        # Store the analysis ID
        if "analysis_id" in result:
            st.session_state.analysis_id = result["analysis_id"]
        
        # Update analysis history
        if ticker not in st.session_state.analysis_history:
            st.session_state.analysis_history[ticker] = []
        
        # Add to history (limited to last 5)
        st.session_state.analysis_history[ticker].append({
            "timestamp": datetime.now().isoformat(),
            "analysis_type": analysis_type,
            "risk_tolerance": risk_tolerance,
            "result": result
        })
        
        if len(st.session_state.analysis_history[ticker]) > 5:
            st.session_state.analysis_history[ticker].pop(0)
        
        return result
    
    except Exception as e:
        logger.error(f"Error running analysis: {str(e)}")
        return {"error": str(e)}

def collect_technical_indicators(ticker, period="1y", interval="1d"):
    """
    Collect and store technical indicators for a ticker
    
    Args:
        ticker: Ticker symbol
        period: Data period
        interval: Data interval
        
    Returns:
        Dictionary with indicator data
    """
    try:
        indicators_data = st.session_state.tech_storage.collect_and_store_indicators(
            ticker=ticker,
            period=period,
            interval=interval
        )
        
        # Store in session state
        st.session_state.indicator_data[ticker] = indicators_data
        
        return indicators_data
    
    except Exception as e:
        logger.error(f"Error collecting technical indicators: {str(e)}")
        return {}

def get_indicator_trends(ticker, indicator_name, days=30):
    """
    Get trends for a specific indicator
    
    Args:
        ticker: Ticker symbol
        indicator_name: Name of the indicator
        days: Number of days to analyze
        
    Returns:
        Dictionary with trend data
    """
    try:
        return st.session_state.memory_analyzer.get_technical_indicator_trends(
            ticker=ticker,
            indicator_name=indicator_name,
            days=days
        )
    except Exception as e:
        logger.error(f"Error getting indicator trends: {str(e)}")
        return {"error": str(e)}

def add_user_feedback(analysis_id, feedback_type, feedback_text):
    """
    Add user feedback for an analysis
    
    Args:
        analysis_id: ID of the analysis
        feedback_type: Type of feedback
        feedback_text: Text of the feedback
    """
    try:
        st.session_state.memory_analyzer.add_user_feedback(
            analysis_id=analysis_id,
            feedback_type=feedback_type,
            feedback_text=feedback_text
        )
        return True
    except Exception as e:
        logger.error(f"Error adding feedback: {str(e)}")
        return False

def get_analysis_history(ticker, limit=5):
    """
    Get historical analyses for a ticker from the memory database
    
    Args:
        ticker: Ticker symbol
        limit: Maximum number of analyses to return
        
    Returns:
        List of historical analyses
    """
    try:
        return st.session_state.memory_analyzer.get_analysis_history(ticker, limit)
    except Exception as e:
        logger.error(f"Error getting analysis history: {str(e)}")
        return []

def get_recommendation_accuracy(ticker):
    """
    Get recommendation accuracy for a ticker
    
    Args:
        ticker: Ticker symbol
        
    Returns:
        Dictionary with accuracy metrics
    """
    try:
        return st.session_state.memory_analyzer.get_recommendation_accuracy(ticker)
    except Exception as e:
        logger.error(f"Error getting recommendation accuracy: {str(e)}")
        return {"accuracy": 0, "correct": 0, "total": 0}

def display_market_overview(result, ticker):
    """
    Display market overview section
    
    Args:
        result: Analysis result
        ticker: Ticker symbol
    """
    if result is None:
        st.error("No analysis result available. Please run the analysis first.")
        return
        
    if "market_overview" not in result:
        st.warning("No market overview data available in the analysis result.")
        return
    
    overview = result["market_overview"]
    
    # Create columns for metrics
    col1, col2, col3 = st.columns(3)
    
    with col1:
        sentiment = overview.get("sentiment", "N/A")
        sentiment_color = "green" if sentiment == "bullish" else "red" if sentiment == "bearish" else "gray"
        st.metric("Market Sentiment", sentiment)
    
    with col2:
        # Display key factors if available
        if "key_factors" in overview:
            st.write("Key Market Factors:")
            for factor in overview["key_factors"]:
                st.markdown(f"- {factor}")
    
    with col3:
        # Display summary
        st.write("Market Summary:")
        st.write(overview.get("summary", "No summary available"))

def display_ticker_analysis(result, ticker):
    """
    Display ticker analysis section
    
    Args:
        result: Analysis result
        ticker: Ticker symbol
    """
    if "ticker_analysis" not in result or ticker not in result["ticker_analysis"]:
        st.warning("No ticker analysis available")
        return
    
    analysis = result["ticker_analysis"][ticker]
    
    # Create columns for metrics
    col1, col2, col3 = st.columns(3)
    
    with col1:
        recommendation = analysis.get("recommendation", "N/A")
        rec_color = "green" if recommendation == "buy" else "red" if recommendation == "sell" else "gray"
        st.metric("Recommendation", recommendation)
    
    with col2:
        if "risk_assessment" in analysis:
            risk_level = analysis["risk_assessment"].get("overall_risk", "N/A")
        else:
            risk_level = "N/A"
        risk_color = "red" if risk_level == "high" else "orange" if risk_level == "medium" else "green"
        st.metric("Risk Level", risk_level)
    
    with col3:
        confidence = analysis.get("confidence", "N/A")
        st.metric("Confidence", confidence)
    
    # Technical indicators
    if "technical_indicators" in analysis:
        st.subheader("Technical Analysis")
        tech = analysis["technical_indicators"]
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.metric("Trend", tech.get("trend", "N/A"))
            st.metric("Strength", tech.get("strength", "N/A"))
        
        with col2:
            if "patterns" in tech:
                st.subheader("Patterns")
                for pattern in tech["patterns"]:
                    st.markdown(f"- {pattern}")
            
            if "signals" in tech:
                st.subheader("Signals")
                for signal in tech["signals"]:
                    st.markdown(f"- {signal}")
        
        # Support and resistance levels
        if "key_levels" in tech:
            st.subheader("Key Price Levels")
            levels = tech["key_levels"]
            
            # Create a range for the chart
            support_levels = levels.get("support", [])
            resistance_levels = levels.get("resistance", [])
            
            current_price = analysis.get("current_price", 0)
            
            # Create a range for the chart
            all_levels = support_levels + resistance_levels + [current_price]
            if all_levels:
                min_price = min(all_levels) * 0.95
                max_price = max(all_levels) * 1.05
                
                # Create a candlestick-like chart with support and resistance
                fig = go.Figure()
                
                # Add support levels
                for level in support_levels:
                    fig.add_shape(
                        type="line",
                        x0=0,
                        y0=level,
                        x1=1,
                        y1=level,
                        line=dict(
                            color="green",
                            width=2,
                            dash="dash",
                        ),
                    )
                    fig.add_annotation(
                        x=0.1,
                        y=level,
                        text=f"Support: ${level:.2f}",
                        showarrow=False,
                        xshift=-50,
                    )
                
                # Add resistance levels
                for level in resistance_levels:
                    fig.add_shape(
                        type="line",
                        x0=0,
                        y0=level,
                        x1=1,
                        y1=level,
                        line=dict(
                            color="red",
                            width=2,
                            dash="dash",
                        ),
                    )
                    fig.add_annotation(
                        x=0.9,
                        y=level,
                        text=f"Resistance: ${level:.2f}",
                        showarrow=False,
                        xshift=50,
                    )
                
                # Add current price
                fig.add_shape(
                    type="line",
                    x0=0,
                    y0=current_price,
                    x1=1,
                    y1=current_price,
                    line=dict(
                        color="blue",
                        width=3,
                    ),
                )
                
                # Add annotations
                fig.add_annotation(
                    x=0.5,
                    y=current_price,
                    text=f"Current: ${current_price:.2f}",
                    showarrow=False,
                    yshift=10,
                )
                
                # Update layout
                fig.update_layout(
                    title=f"{ticker} Support & Resistance Levels",
                    xaxis=dict(
                        showgrid=False,
                        zeroline=False,
                        showticklabels=False,
                    ),
                    yaxis=dict(
                        range=[min_price, max_price],
                    ),
                    showlegend=False,
                    height=400,
                )
                
                st.plotly_chart(fig, use_container_width=True)
    
    # Price targets
    if "price_targets" in analysis:
        st.subheader("Price Targets")
        targets = analysis["price_targets"]
        
        col1, col2 = st.columns(2)
        
        with col1:
            if "short_term" in targets:
                short_term = targets["short_term"]
                st.metric(
                    f"Short-Term ({short_term.get('timeframe', 'N/A')})", 
                    f"${short_term.get('target', 0):.2f}",
                    f"Confidence: {short_term.get('confidence', 'N/A')}"
                )
        
        with col2:
            if "long_term" in targets:
                long_term = targets["long_term"]
                st.metric(
                    f"Long-Term ({long_term.get('timeframe', 'N/A')})", 
                    f"${long_term.get('target', 0):.2f}",
                    f"Confidence: {long_term.get('confidence', 'N/A')}"
                )
    
    # Trading strategy
    if "trading_strategy" in analysis:
        st.subheader("Trading Strategy")
        strategy = analysis["trading_strategy"]
        
        col1, col2 = st.columns(2)
        
        with col1:
            if "entry_points" in strategy:
                st.write("**Entry Points:**")
                for point in strategy["entry_points"]:
                    st.markdown(f"- ${point:.2f}")
            
            if "stop_loss" in strategy:
                st.metric("Stop Loss", f"${strategy['stop_loss']:.2f}")
        
        with col2:
            if "exit_points" in strategy:
                st.write("**Exit Points:**")
                for point in strategy["exit_points"]:
                    st.markdown(f"- ${point:.2f}")
            
            if "take_profit" in strategy:
                st.metric("Take Profit", f"${strategy['take_profit']:.2f}")
        
        if "position_sizing" in strategy:
            st.write(f"**Position Sizing:** {strategy['position_sizing']}")
        
        if "risk_management" in strategy:
            st.write(f"**Risk Management:** {strategy['risk_management']}")
    
    # Historical comparison
    if "historical_comparison" in analysis:
        st.subheader("Historical Comparison")
        comparison = analysis["historical_comparison"]
        
        if "similar_periods" in comparison:
            st.write("**Similar Historical Periods:**")
            for period in comparison["similar_periods"]:
                st.markdown(f"- {period}")
        
        if "differences" in comparison:
            st.write("**Key Differences:**")
            for diff in comparison["differences"]:
                st.markdown(f"- {diff}")
        
        if "implications" in comparison:
            st.write(f"**Implications:** {comparison['implications']}")

def display_technical_insights(result):
    """
    Display technical insights section
    
    Args:
        result: Analysis result
    """
    if "technical_insights" not in result or not result["technical_insights"]:
        st.warning("No technical insights available")
        return
    
    insights = result["technical_insights"]
    
    for insight in insights:
        col1, col2, col3 = st.columns([1, 1, 2])
        
        with col1:
            indicator = insight.get("indicator", "N/A")
            st.markdown(f"**{indicator}**")
        
        with col2:
            signal = insight.get("signal", "N/A")
            strength = insight.get("strength", "N/A")
            signal_color = "green" if signal == "bullish" else "red" if signal == "bearish" else "gray"
            st.markdown(f"**Signal:** {signal} ({strength})")
        
        with col3:
            description = insight.get("description", "N/A")
            st.markdown(f"**Description:** {description}")
        
        st.markdown("---")

def display_learning_points(result):
    """
    Display learning points section
    
    Args:
        result: Analysis result
    """
    if "learning_points" not in result or not result["learning_points"]:
        st.warning("No learning points available")
        return
    
    points = result["learning_points"]
    
    for i, point in enumerate(points, 1):
        st.markdown(f"{i}. {point}")

def display_technical_indicators(ticker):
    """
    Display technical indicators section
    
    Args:
        ticker: Ticker symbol
    """
    # Check if we have indicator data for this ticker
    if ticker not in st.session_state.indicator_data:
        # Try to collect indicators
        with st.spinner(f"Collecting technical indicators for {ticker}..."):
            indicators_data = collect_technical_indicators(ticker)
            
            if not indicators_data:
                st.warning(f"No technical indicator data available for {ticker}")
                return
    else:
        indicators_data = st.session_state.indicator_data[ticker]
    
    # Display available indicators
    st.subheader("Available Technical Indicators")
    
    # Group indicators by category
    indicators_by_category = {}
    for name, data in indicators_data.items():
        category = data.get('category', 'unknown')
        if category not in indicators_by_category:
            indicators_by_category[category] = []
        indicators_by_category[category].append(name)
    
    # Display indicators by category
    for category, indicators in indicators_by_category.items():
        st.write(f"**{category.capitalize()} Indicators:**")
        for indicator in indicators:
            st.markdown(f"- {indicator}")
    
    # Allow user to select an indicator for trend analysis
    selected_indicator = st.selectbox(
        "Select an indicator for trend analysis",
        list(indicators_data.keys())
    )
    
    days = st.slider("Number of days for trend analysis", 5, 60, 30)
    
    if st.button(f"Analyze {selected_indicator} Trends"):
        with st.spinner(f"Analyzing {selected_indicator} trends for {ticker}..."):
            trend_data = get_indicator_trends(ticker, selected_indicator, days)
            
            if trend_data and 'error' not in trend_data:
                display_indicator_trends(ticker, selected_indicator, trend_data)
            else:
                st.error(f"Error getting trend data: {trend_data.get('error', 'Unknown error')}")

def display_indicator_trends(ticker, indicator_name, trend_data):
    """
    Display indicator trends
    
    Args:
        ticker: Ticker symbol
        indicator_name: Name of the indicator
        trend_data: Trend data dictionary
    """
    st.subheader(f"{indicator_name} Trends for {ticker}")
    
    # Check if we have timestamps and values
    if not trend_data.get('timestamps') or not trend_data.get('values'):
        st.warning("No trend data available")
        return
    
    # Create a figure for each value
    for key, values in trend_data['values'].items():
        if not values:
            continue
        
        fig = go.Figure()
        
        fig.add_trace(go.Scatter(
            x=trend_data['timestamps'],
            y=values,
            mode='lines+markers',
            name=key,
            line=dict(width=2),
            marker=dict(size=8)
        ))
        
        fig.update_layout(
            title=f"{indicator_name} - {key}",
            xaxis_title="Date",
            yaxis_title="Value",
            height=400,
            hovermode="x unified"
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    # Display signals if available
    if trend_data.get('signals'):
        st.subheader("Signal History")
        
        for signal_type, signals in trend_data['signals'].items():
            if not signals:
                continue
            
            st.write(f"**{signal_type}:**")
            
            # Create a dataframe for the signals
            signal_data = []
            for i, signal in enumerate(signals):
                if i < len(trend_data['timestamps']):
                    signal_data.append({
                        "Date": trend_data['timestamps'][i],
                        "Signal": signal
                    })
            
            if signal_data:
                df = pd.DataFrame(signal_data)
                st.dataframe(df)

def display_analysis_history(ticker):
    """
    Display analysis history section
    
    Args:
        ticker: Ticker symbol
    """
    history = get_analysis_history(ticker)
    
    if not history:
        st.warning(f"No analysis history available for {ticker}")
        return
    
    # Create a dataframe for the history
    history_data = []
    
    for analysis in history:
        timestamp = datetime.fromisoformat(analysis["timestamp"]).strftime("%Y-%m-%d %H:%M")
        
        # Extract key information
        sentiment = analysis.get("market_sentiment", "unknown")
        recommendation = analysis.get("recommendation", "unknown")
        price = analysis.get("current_price", 0)
        
        # Get the latest price update if available
        latest_price = price
        price_change = 0
        
        if "price_history" in analysis and analysis["price_history"]:
            latest = analysis["price_history"][-1]
            latest_price = latest["price"]
            price_change = ((latest_price - price) / price) * 100 if price > 0 else 0
        
        history_data.append({
            "Date": timestamp,
            "Price": f"${price:.2f}",
            "Latest Price": f"${latest_price:.2f}",
            "Change": f"{price_change:.2f}%",
            "Sentiment": sentiment,
            "Recommendation": recommendation
        })
    
    # Create a dataframe
    df = pd.DataFrame(history_data)
    
    # Display the dataframe
    st.dataframe(df)
    
    # Display accuracy metrics
    accuracy = get_recommendation_accuracy(ticker)
    
    if accuracy["total"] > 0:
        st.metric("Recommendation Accuracy", f"{accuracy['accuracy']*100:.1f}%", f"{accuracy['correct']}/{accuracy['total']} correct")

def display_feedback_form():
    """
    Display a form for user feedback
    """
    if st.session_state.analysis_id is None:
        st.warning("No analysis available for feedback")
        return
    
    with st.form("feedback_form"):
        st.subheader("Provide Feedback")
        
        feedback_type = st.selectbox(
            "Feedback Type",
            ["accuracy", "usefulness", "insight", "other"]
        )
        
        feedback_text = st.text_area(
            "Your Feedback",
            "The analysis was..."
        )
        
        submitted = st.form_submit_button("Submit Feedback")
        
        if submitted:
            success = add_user_feedback(
                analysis_id=st.session_state.analysis_id,
                feedback_type=feedback_type,
                feedback_text=feedback_text
            )
            
            if success:
                st.success("Feedback submitted successfully!")
            else:
                st.error("Error submitting feedback")

def store_trend_analysis(ticker, trend_text):
    """
    Parse and store trend analysis data from text
    
    Args:
        ticker: Ticker symbol
        trend_text: Text containing trend analysis data
        
    Returns:
        ID of the stored analysis
    """
    try:
        # Parse the trend analysis text
        analysis_data = st.session_state.trend_storage.parse_trend_analysis_from_text(trend_text)
        
        # Store the analysis
        analysis_id = st.session_state.trend_storage.store_trend_analysis(ticker, analysis_data)
        
        # Store the ID in session state
        st.session_state.trend_analysis_id = analysis_id
        
        return analysis_id
    
    except Exception as e:
        logger.error(f"Error storing trend analysis: {str(e)}")
        return None

def get_trend_analysis_history(ticker, limit=5):
    """
    Get historical trend analysis data for a ticker
    
    Args:
        ticker: Ticker symbol
        limit: Maximum number of records to retrieve
        
    Returns:
        List of trend analysis records
    """
    try:
        return st.session_state.trend_storage.get_trend_analysis_history(ticker, limit)
    
    except Exception as e:
        logger.error(f"Error getting trend analysis history: {str(e)}")
        return []

def get_trend_indicator_history(ticker, indicator, limit=10):
    """
    Get historical values for a specific trend indicator
    
    Args:
        ticker: Ticker symbol
        indicator: Indicator name
        limit: Maximum number of records to retrieve
        
    Returns:
        Dictionary with trend data
    """
    try:
        return st.session_state.trend_storage.get_indicator_trends(ticker, indicator, limit)
    
    except Exception as e:
        logger.error(f"Error getting trend indicator history: {str(e)}")
        return {"error": str(e)}

def verify_trend_prediction(trend_analysis_id, prediction_type, prediction_value, target_price, actual_price, was_correct, accuracy_score):
    """
    Store verification of a trend prediction
    
    Args:
        trend_analysis_id: ID of the trend analysis
        prediction_type: Type of prediction (e.g., "short_term", "medium_term")
        prediction_value: Value of the prediction (e.g., "bullish", "bearish")
        target_price: Target price from the prediction
        actual_price: Actual price at verification time
        was_correct: Whether the prediction was correct
        accuracy_score: Score representing prediction accuracy (0.0-1.0)
        
    Returns:
        ID of the stored verification
    """
    try:
        return st.session_state.trend_storage.store_prediction_verification(
            trend_analysis_id=trend_analysis_id,
            prediction_type=prediction_type,
            prediction_value=prediction_value,
            target_price=target_price,
            actual_price=actual_price,
            was_correct=was_correct,
            accuracy_score=accuracy_score
        )
    
    except Exception as e:
        logger.error(f"Error verifying trend prediction: {str(e)}")
        return None

def get_trend_prediction_accuracy(ticker, prediction_type=None):
    """
    Get trend prediction accuracy metrics for a ticker
    
    Args:
        ticker: Ticker symbol
        prediction_type: Optional type of prediction to filter by
        
    Returns:
        Dictionary with accuracy metrics
    """
    try:
        return st.session_state.trend_storage.get_prediction_accuracy(ticker, prediction_type)
    
    except Exception as e:
        logger.error(f"Error getting trend prediction accuracy: {str(e)}")
        return {}

def display_trend_analysis_history(ticker):
    """
    Display trend analysis history section
    
    Args:
        ticker: Ticker symbol
    """
    history = get_trend_analysis_history(ticker)
    
    if not history:
        st.warning(f"No trend analysis history available for {ticker}")
        return
    
    # Create a dataframe for the history
    history_data = []
    
    for analysis in history:
        timestamp = datetime.fromisoformat(analysis["timestamp"]).strftime("%Y-%m-%d %H:%M")
        
        # Extract key information
        primary_trend = analysis.get("primary_trend", "unknown")
        trend_strength = analysis.get("trend_strength", 0)
        rsi_value = analysis.get("rsi_value", 0)
        rsi_condition = analysis.get("rsi_condition", "unknown")
        macd_signal = analysis.get("macd_signal", "unknown")
        
        history_data.append({
            "Date": timestamp,
            "Primary Trend": primary_trend,
            "Trend Strength": f"{trend_strength}%",
            "RSI": f"{rsi_value} ({rsi_condition})",
            "MACD": macd_signal
        })
    
    # Create a dataframe
    df = pd.DataFrame(history_data)
    
    # Display the dataframe
    st.dataframe(df)
    
    # Display accuracy metrics
    accuracy = get_trend_prediction_accuracy(ticker)
    
    if 'overall' in accuracy and accuracy['overall']['total_predictions'] > 0:
        overall = accuracy['overall']
        st.metric(
            "Prediction Accuracy", 
            f"{overall['accuracy']*100:.1f}%", 
            f"{overall['correct_predictions']}/{overall['total_predictions']} correct"
        )
    
    # Allow user to select an indicator for trend history
    st.subheader("Trend Indicator History")
    
    indicator_options = [
        "trend_strength", "rsi_value", "macd_strength", 
        "bollinger_bandwidth", "support_confidence", "resistance_confidence",
        "short_term_confidence", "medium_term_confidence", "overall_confidence"
    ]
    
    selected_indicator = st.selectbox(
        "Select an indicator to view historical trends",
        indicator_options,
        format_func=lambda x: x.replace("_", " ").title()
    )
    
    if st.button(f"View {selected_indicator.replace('_', ' ').title()} History"):
        with st.spinner(f"Loading {selected_indicator} history..."):
            trend_data = get_trend_indicator_history(ticker, selected_indicator, limit=20)
            
            if trend_data and 'error' not in trend_data:
                display_trend_indicator_history(ticker, selected_indicator, trend_data)
            else:
                st.error(f"Error getting trend data: {trend_data.get('error', 'Unknown error')}")

def display_trend_indicator_history(ticker, indicator_name, trend_data):
    """
    Display trend indicator history
    
    Args:
        ticker: Ticker symbol
        indicator_name: Name of the indicator
        trend_data: Trend data dictionary
    """
    st.subheader(f"{indicator_name.replace('_', ' ').title()} History for {ticker}")
    
    # Check if we have timestamps and values
    if not trend_data.get('timestamps') or not trend_data.get('values'):
        st.warning("No trend data available")
        return
    
    # Create a figure
    fig = go.Figure()
    
    fig.add_trace(go.Scatter(
        x=trend_data['timestamps'],
        y=trend_data['values'],
        mode='lines+markers',
        name=indicator_name.replace('_', ' ').title(),
        line=dict(width=2),
        marker=dict(size=8)
    ))
    
    fig.update_layout(
        title=f"{indicator_name.replace('_', ' ').title()} History",
        xaxis_title="Date",
        yaxis_title="Value",
        height=400,
        hovermode="x unified"
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # Create a dataframe for the history
    history_data = []
    
    for i, timestamp in enumerate(trend_data['timestamps']):
        if i < len(trend_data['values']):
            history_data.append({
                "Date": timestamp,
                indicator_name.replace('_', ' ').title(): trend_data['values'][i]
            })
    
    if history_data:
        df = pd.DataFrame(history_data)
        st.dataframe(df)

def generate_and_store_trend_analysis(ticker, analysis_result):
    """
    Generate and store trend analysis from analysis result
    
    Args:
        ticker: Ticker symbol
        analysis_result: Analysis result dictionary
        
    Returns:
        ID of the stored trend analysis
    """
    try:
        if not analysis_result or "error" in analysis_result:
            logger.error(f"Cannot generate trend analysis: Invalid analysis result")
            return None
            
        # Extract trend data from analysis result
        trend_data = {}
        
        # Extract primary trend
        if "ticker_analysis" in analysis_result and ticker in analysis_result["ticker_analysis"]:
            ticker_analysis = analysis_result["ticker_analysis"][ticker]
            
            if "technical_indicators" in ticker_analysis:
                tech = ticker_analysis["technical_indicators"]
                trend_data["primary_trend"] = tech.get("trend", "NEUTRAL").upper()
                trend_data["trend_strength"] = int(tech.get("strength", "50").replace("%", ""))
                trend_data["trend_duration"] = "short-term"  # Default
                
                # Extract support and resistance levels
                if "key_levels" in tech:
                    levels = tech["key_levels"]
                    trend_data["support_levels"] = levels.get("support", [])
                    trend_data["resistance_levels"] = levels.get("resistance", [])
                    trend_data["support_confidence"] = 70  # Default
                    trend_data["resistance_confidence"] = 70  # Default
        
        # Extract RSI data
        if "technical_insights" in analysis_result:
            for insight in analysis_result["technical_insights"]:
                if insight.get("indicator") == "RSI":
                    trend_data["rsi_value"] = float(insight.get("value", 50))
                    signal = insight.get("signal", "").lower()
                    
                    if "oversold" in signal:
                        trend_data["rsi_condition"] = "OVERSOLD"
                    elif "overbought" in signal:
                        trend_data["rsi_condition"] = "OVERBOUGHT"
                    else:
                        trend_data["rsi_condition"] = "NEUTRAL"
                
                elif insight.get("indicator") == "MACD":
                    trend_data["macd_signal"] = insight.get("signal", "NEUTRAL").upper()
                    trend_data["macd_strength"] = int(insight.get("strength", "50").replace("%", ""))
                
                elif insight.get("indicator") == "Bollinger Bands":
                    position = insight.get("description", "").lower()
                    if "lower" in position:
                        trend_data["bollinger_position"] = "lower"
                    elif "upper" in position:
                        trend_data["bollinger_position"] = "upper"
                    else:
                        trend_data["bollinger_position"] = "middle"
                    
                    trend_data["bollinger_bandwidth"] = 50  # Default
                    trend_data["bollinger_squeeze"] = False  # Default
        
        # Set price targets
        if "ticker_analysis" in analysis_result and ticker in analysis_result["ticker_analysis"]:
            ticker_analysis = analysis_result["ticker_analysis"][ticker]
            current_price = ticker_analysis.get("current_price", 0)
            
            if "price_targets" in ticker_analysis:
                targets = ticker_analysis["price_targets"]
                
                if "short_term" in targets:
                    short_term = targets["short_term"]
                    trend_data["short_term_bullish_target"] = short_term.get("target", current_price * 1.05)
                    trend_data["short_term_bearish_target"] = current_price * 0.95  # Default
                    trend_data["short_term_confidence"] = int(short_term.get("confidence", "50").replace("%", ""))
                    trend_data["short_term_timeframe"] = short_term.get("timeframe", "1-2 weeks")
                else:
                    # Default values
                    trend_data["short_term_bullish_target"] = current_price * 1.05
                    trend_data["short_term_bearish_target"] = current_price * 0.95
                    trend_data["short_term_confidence"] = 50
                    trend_data["short_term_timeframe"] = "1-2 weeks"
                
                if "long_term" in targets:
                    long_term = targets["long_term"]
                    trend_data["medium_term_bullish_target"] = long_term.get("target", current_price * 1.10)
                    trend_data["medium_term_bearish_target"] = current_price * 0.90  # Default
                    trend_data["medium_term_confidence"] = int(long_term.get("confidence", "50").replace("%", ""))
                    trend_data["medium_term_timeframe"] = long_term.get("timeframe", "1-3 months")
                else:
                    # Default values
                    trend_data["medium_term_bullish_target"] = current_price * 1.10
                    trend_data["medium_term_bearish_target"] = current_price * 0.90
                    trend_data["medium_term_confidence"] = 50
                    trend_data["medium_term_timeframe"] = "1-3 months"
            
            # Set risk assessment
            if "trading_strategy" in ticker_analysis:
                strategy = ticker_analysis["trading_strategy"]
                trend_data["stop_loss"] = strategy.get("stop_loss", current_price * 0.95)
                trend_data["risk_reward_ratio"] = 1.5  # Default
                trend_data["volatility_risk"] = "MEDIUM"  # Default
                trend_data["risk_factors"] = ["Market sentiment", "Technical levels", "Volatility"]  # Default
            else:
                # Default values
                trend_data["stop_loss"] = current_price * 0.95
                trend_data["risk_reward_ratio"] = 1.5
                trend_data["volatility_risk"] = "MEDIUM"
                trend_data["risk_factors"] = ["Market sentiment", "Technical levels", "Volatility"]
        
        # Set analysis summary and confidence
        if "market_overview" in analysis_result:
            overview = analysis_result["market_overview"]
            trend_data["analysis_summary"] = overview.get("summary", "No summary available")
            trend_data["overall_confidence"] = 65  # Default
        
        # Store the trend analysis
        analysis_id = st.session_state.trend_storage.store_trend_analysis(ticker, trend_data)
        
        # Store the ID in session state
        st.session_state.trend_analysis_id = analysis_id
        
        return analysis_id
    
    except Exception as e:
        logger.error(f"Error generating and storing trend analysis: {str(e)}")
        return None

def display_analysis(result, ticker):
    """
    Display the analysis result in a structured format with tabs
    
    Args:
        result: Analysis result dictionary
        ticker: Ticker symbol
    """
    if result is None:
        st.error("No analysis result available. Please run the analysis first.")
        return
        
    # Create tabs for different sections
    market_tab, ticker_tab, technical_tab, learning_tab, verification_tab, timeline_tab = st.tabs([
        "Market Overview", 
        "Ticker Analysis", 
        "Technical Insights",
        "Learning Points",
        "Price Target Verification",
        "Prediction Timeline"
    ])
    
    with market_tab:
        display_market_overview(result, ticker)
        
    with ticker_tab:
        display_ticker_analysis(result, ticker)
        
    with technical_tab:
        display_technical_insights(result)
        
    with learning_tab:
        display_learning_points(result)
        
    with verification_tab:
        try:
            from src.ui.price_target_verification_ui import display_prediction_verification
            display_prediction_verification(ticker)
        except ImportError:
            st.warning("Price target verification module not available. Please install the required dependencies.")
        
    with timeline_tab:
        try:
            from src.ui.price_target_verification_ui import display_prediction_timeline
            display_prediction_timeline(ticker)
        except ImportError:
            st.warning("Price target verification module not available. Please install the required dependencies.")

def main():
    """Main function for the Streamlit app"""
    st.title("AI Hedge Fund - Memory Enhanced Analysis")
    
    # Initialize session state
    if 'current_analysis' not in st.session_state:
        st.session_state.current_analysis = None
    
    # Sidebar
    with st.sidebar:
        st.header("Analysis Parameters")
        
        # Ticker input
        ticker = st.text_input("Enter Ticker Symbol", value="SPY").upper()
        
        # Analysis type selection
        analysis_type = st.selectbox(
            "Select Analysis Type",
            ["Basic", "Comprehensive", "Options Enhanced"],
            index=1
        )
        
        # Risk tolerance selection
        risk_tolerance = st.select_slider(
            "Risk Tolerance",
            options=["Very Low", "Low", "Moderate", "High", "Very High"],
            value="Moderate"
        )
        
        # Run analysis button
        if st.button("Run Analysis"):
            with st.spinner("Running analysis..."):
                try:
                    # Run the analysis
                    st.session_state.current_analysis = run_analysis(ticker, analysis_type, risk_tolerance)
                    
                    # Store trend analysis automatically
                    if st.session_state.current_analysis:
                        analysis_id = generate_and_store_trend_analysis(ticker, st.session_state.current_analysis)
                        if analysis_id:
                            logger.info(f"Automatically stored trend analysis for {ticker} with ID {analysis_id}")
                            
                    st.success("Analysis completed!")
                except Exception as e:
                    st.error(f"Error running analysis: {str(e)}")
                    logger.error(f"Error in analysis: {str(e)}", exc_info=True)
                    st.session_state.current_analysis = None
    
    # Display the analysis result if available
    if st.session_state.current_analysis is not None:
        display_analysis(st.session_state.current_analysis, ticker)
    else:
        st.info("Please enter a ticker symbol and run the analysis to get started.")
    
    # Display technical indicators
    st.header("Technical Indicators")
    display_technical_indicators(ticker)
    
    # Display trend analysis history
    st.header("Analysis History")
    display_trend_analysis_history(ticker)
    
    # Display feedback form
    st.header("Feedback")
    display_feedback_form()

if __name__ == "__main__":
    main() 