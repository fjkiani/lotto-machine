"""
ðŸ§ª REDDIT EXPLOITER INTEGRATION TESTS - Task 5.13
Test Reddit checker integration with UnifiedMonitor.
"""

import unittest
import os
import sys
from datetime import datetime
from unittest.mock import Mock, patch, MagicMock

# Add paths
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from live_monitoring.exploitation.reddit_exploiter import RedditExploiter, RedditRealTimeMonitor, WSBAnalyzer
from live_monitoring.orchestrator.checkers.reddit_checker import RedditChecker
from live_monitoring.orchestrator.alert_manager import AlertManager


class TestRedditIntegration(unittest.TestCase):
    """Integration tests for Reddit Exploiter - Task 5.13"""
    
    def setUp(self):
        """Set up test fixtures"""
        self.api_key = os.getenv('CHARTEXCHANGE_API_KEY', 'test_key')
        self.alert_manager = AlertManager()
    
    def test_reddit_exploiter_initialization(self):
        """Test RedditExploiter initializes correctly"""
        exploiter = RedditExploiter(api_key=self.api_key)
        
        self.assertIsNotNone(exploiter)
        self.assertEqual(exploiter.rate_limit_per_minute, 1000)
        self.assertGreater(len(exploiter.scan_universe), 40)  # Expanded universe
        self.assertIsNotNone(exploiter.wsb_analyzer)
        self.assertIsNotNone(exploiter.subreddit_weights)
    
    def test_reddit_checker_initialization(self):
        """Test RedditChecker initializes correctly"""
        checker = RedditChecker(
            alert_manager=self.alert_manager,
            unified_mode=True,
            api_key=self.api_key
        )
        
        self.assertIsNotNone(checker)
        self.assertEqual(checker.name, "RedditChecker")
    
    def test_rate_limit_management(self):
        """Test rate limit management doesn't break system"""
        exploiter = RedditExploiter(api_key=self.api_key)
        
        # Check rate limit status
        status = exploiter.get_rate_limit_status()
        self.assertIn('requests_last_minute', status)
        self.assertIn('rate_limit', status)
        self.assertIn('remaining', status)
        self.assertIn('can_make_request', status)
        
        # Should allow requests initially
        self.assertTrue(exploiter._check_rate_limit())
    
    def test_sentiment_history_persistence(self):
        """Test sentiment history persists correctly"""
        exploiter = RedditExploiter(api_key=self.api_key)
        
        # Get history for a symbol
        history = exploiter._get_sentiment_history('TSLA')
        self.assertIsNotNone(history)
        
        # Add datapoint
        history.add_datapoint(
            timestamp=datetime.now(),
            sentiment=0.5,
            mentions=100,
            bullish_pct=60.0,
            bearish_pct=20.0,
            wsb_dominance=50.0
        )
        
        # Retrieve history
        hist = history.get_history(days=7)
        self.assertGreaterEqual(len(hist), 1)
        
        # Check trend detection
        trend = history.get_trend(lookback_days=7)
        self.assertIn(trend, ["BULLISH_SHIFT", "BEARISH_SHIFT", "STABLE", "INSUFFICIENT_DATA"])
    
    def test_wsb_analyzer(self):
        """Test WSB analyzer works correctly"""
        from live_monitoring.exploitation.reddit_exploiter import RedditMention
        
        analyzer = WSBAnalyzer()
        
        # Create mock mentions
        mentions = [
            RedditMention(
                subreddit='wallstreetbets',
                created=datetime.now(),
                sentiment=0.8,
                author='test',
                text='ðŸš€ðŸš€ðŸš€ TO THE MOON! ðŸ’ŽðŸ’ŽðŸ’Ž DIAMOND HANDS!',
                link='',
                thing_type='comment'
            ),
            RedditMention(
                subreddit='wallstreetbets',
                created=datetime.now(),
                sentiment=0.7,
                author='test',
                text='YOLO all in!',
                link='',
                thing_type='comment'
            ),
            RedditMention(
                subreddit='stocks',
                created=datetime.now(),
                sentiment=0.3,
                author='test',
                text='Normal post',
                link='',
                thing_type='comment'
            )
        ]
        
        analysis = analyzer.analyze_wsb_activity(mentions)
        
        self.assertIn('wsb_dominance', analysis)
        self.assertIn('yolo_score', analysis)
        self.assertIn('is_meme_mode', analysis)
        self.assertIn('risk_level', analysis)
        self.assertGreater(analysis['wsb_dominance'], 50)  # Should be >50% WSB
        self.assertGreater(analysis['yolo_score'], 0)
    
    def test_weighted_sentiment_calculation(self):
        """Test subreddit-weighted sentiment calculation"""
        exploiter = RedditExploiter(api_key=self.api_key)
        
        from live_monitoring.exploitation.reddit_exploiter import RedditMention
        
        # Create mentions from different subreddits
        mentions = [
            RedditMention('wallstreetbets', datetime.now(), 0.8, 'test', 'YOLO', '', 'comment'),
            RedditMention('ValueInvesting', datetime.now(), 0.5, 'test', 'Good value', '', 'comment'),
            RedditMention('stocks', datetime.now(), 0.3, 'test', 'Normal', '', 'comment')
        ]
        
        weighted = exploiter.calculate_weighted_sentiment(mentions)
        
        # ValueInvesting should have higher weight than WSB
        # So weighted sentiment should be lower than raw average (0.53)
        self.assertIsInstance(weighted, float)
        self.assertGreaterEqual(weighted, -1.0)
        self.assertLessEqual(weighted, 1.0)
    
    def test_velocity_detection(self):
        """Test mention velocity detection"""
        exploiter = RedditExploiter(api_key=self.api_key)
        
        velocity = exploiter.calculate_mention_velocity('TSLA')
        
        self.assertIn('velocity_1h', velocity)
        self.assertIn('velocity_24h', velocity)
        self.assertIn('acceleration', velocity)
        self.assertIn('is_surging', velocity)
        self.assertIn('surge_multiplier', velocity)
    
    def test_emerging_ticker_discovery(self):
        """Test emerging ticker discovery"""
        exploiter = RedditExploiter(api_key=self.api_key)
        
        emerging = exploiter.discover_emerging_tickers(min_mentions=20, max_mentions=100)
        
        # Should return list
        self.assertIsInstance(emerging, list)
        
        # If any found, check structure
        if emerging:
            ticker = emerging[0]
            self.assertIn('symbol', ticker)
            self.assertIn('mention_count', ticker)
            self.assertIn('velocity', ticker)
            self.assertIn('momentum_score', ticker)
            self.assertGreaterEqual(ticker['mention_count'], 20)
            self.assertLessEqual(ticker['mention_count'], 100)
    
    def test_real_time_monitor(self):
        """Test real-time monitoring mode"""
        exploiter = RedditExploiter(api_key=self.api_key)
        monitor = RedditRealTimeMonitor(exploiter)
        
        # Quick scan should return list
        alerts = monitor.quick_scan(['TSLA', 'NVDA'])
        
        self.assertIsInstance(alerts, list)
        
        # If alerts found, check structure
        if alerts:
            alert = alerts[0]
            self.assertIn('symbol', alert)
            self.assertIn('shift_type', alert)
            self.assertIn('current_sentiment', alert)
            self.assertIn(alert['shift_type'], ['RAPID_BULLISH', 'RAPID_BEARISH'])
    
    def test_price_correlation(self):
        """Test price correlation check"""
        exploiter = RedditExploiter(api_key=self.api_key)
        
        from live_monitoring.exploitation.reddit_exploiter import RedditTickerAnalysis
        
        # Create mock analysis
        analysis = RedditTickerAnalysis(
            symbol='TSLA',
            timestamp=datetime.now(),
            total_mentions=100,
            mentions_today=50,
            mentions_24h_ago=30,
            mention_change_pct=66.7,
            avg_sentiment=0.5,
            bullish_pct=60.0,
            bearish_pct=20.0,
            sentiment_trend="IMPROVING",
            top_subreddits={'wallstreetbets': 50},
            wsb_dominance=50.0,
            signal_type=None,
            signal_strength=0.0,
            action="NEUTRAL"
        )
        
        correlation = exploiter.correlate_with_price('TSLA', analysis)
        
        self.assertIn('price_change_24h', correlation)
        self.assertIn('price_change_7d', correlation)
        self.assertIn('sentiment_price_correlation', correlation)
        self.assertIn('divergence', correlation)
        self.assertIn('confirmation', correlation)
    
    def test_reddit_checker_doesnt_block_others(self):
        """Test Reddit checker runs without blocking other checkers"""
        checker = RedditChecker(
            alert_manager=self.alert_manager,
            unified_mode=True,
            api_key=self.api_key
        )
        
        # Should not raise exceptions
        try:
            alerts = checker.check()
            self.assertIsInstance(alerts, list)
        except Exception as e:
            self.fail(f"Reddit checker raised exception: {e}")
    
    def test_discord_alert_formatting(self):
        """Test Discord alerts format correctly"""
        checker = RedditChecker(
            alert_manager=self.alert_manager,
            unified_mode=True,
            api_key=self.api_key
        )
        
        from live_monitoring.exploitation.reddit_exploiter import (
            RedditTickerAnalysis, RedditSignalType, HotTickerDiscovery
        )
        
        # Test hot ticker embed
        hot_ticker = HotTickerDiscovery(
            symbol='TSLA',
            mention_count=100,
            avg_sentiment=0.6,
            bullish_pct=70.0,
            wsb_mentions=50,
            momentum_score=85.0,
            discovery_reason='ðŸ”¥ BULLISH'
        )
        
        embed = checker._create_hot_ticker_embed(hot_ticker)
        self.assertIn('title', embed)
        self.assertIn('fields', embed)
        self.assertIn('color', embed)
        
        # Test signal embed
        signal = RedditTickerAnalysis(
            symbol='TSLA',
            timestamp=datetime.now(),
            total_mentions=100,
            mentions_today=50,
            mentions_24h_ago=30,
            mention_change_pct=66.7,
            avg_sentiment=0.6,
            bullish_pct=70.0,
            bearish_pct=20.0,
            sentiment_trend="IMPROVING",
            top_subreddits={'wallstreetbets': 50},
            wsb_dominance=50.0,
            signal_type=RedditSignalType.FADE_HYPE,
            signal_strength=80.0,
            action="SHORT",
            reasoning=['Extreme bullish sentiment'],
            warnings=['High WSB dominance'],
            sample_posts=['[+0.8] YOLO!']
        )
        
        embed = checker._create_signal_embed(signal)
        self.assertIn('title', embed)
        self.assertIn('fields', embed)
        self.assertIn('color', embed)
    
    def test_error_handling_doesnt_crash(self):
        """Test error handling doesn't crash UnifiedMonitor"""
        checker = RedditChecker(
            alert_manager=self.alert_manager,
            unified_mode=True,
            api_key='invalid_key'
        )
        
        # Should handle errors gracefully
        alerts = checker.check()
        self.assertIsInstance(alerts, list)  # Should return empty list, not crash
    
    def test_deduplication_works(self):
        """Test alert deduplication works across checkers"""
        checker = RedditChecker(
            alert_manager=self.alert_manager,
            unified_mode=True,
            api_key=self.api_key
        )
        
        # First check
        alerts1 = checker.check()
        
        # Second check immediately (should deduplicate)
        alerts2 = checker.check()
        
        # Should not have duplicate alerts
        alert_keys = set()
        for alert in alerts1 + alerts2:
            key = f"{alert.symbol}_{alert.alert_type}"
            self.assertNotIn(key, alert_keys, "Duplicate alert found!")
            alert_keys.add(key)


if __name__ == '__main__':
    unittest.main()

