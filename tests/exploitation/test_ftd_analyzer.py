#!/usr/bin/env python3
"""
üìà FTD ANALYZER TEST SUITE - Phase 4 Exploitation Module Tests

Tests for the FTD (Failure to Deliver) Analyzer module:
- FTD data fetching and parsing
- FTD metrics calculation
- Signal generation logic
- T+35 calendar generation
- Integration with UnifiedAlphaMonitor

Run with: python3 -m pytest tests/exploitation/test_ftd_analyzer.py -v
Or standalone: python3 tests/exploitation/test_ftd_analyzer.py
"""

import os
import sys
import unittest
from datetime import datetime, timedelta
from typing import Optional, List, Dict
from unittest.mock import Mock, patch, MagicMock

# Add project root to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../..'))

from live_monitoring.exploitation.ftd_analyzer import FTDAnalyzer, FTDSignal


class MockChartExchangeClient:
    """Mock client for testing without API calls."""
    
    def __init__(self, ftd_data: Optional[List] = None):
        self.ftd_data = ftd_data or []
        self.call_count = 0
    
    def get_failure_to_deliver(self, symbol: str, start_date: Optional[str] = None) -> List:
        """Return mock FTD data."""
        self.call_count += 1
        return self.ftd_data


class TestFTDSignalDataclass(unittest.TestCase):
    """Test FTDSignal dataclass."""
    
    def test_ftd_signal_creation(self):
        """Test creating FTDSignal with all fields."""
        signal = FTDSignal(
            symbol='GME',
            timestamp=datetime.now(),
            signal_type='SPIKE',
            score=75.0,
            ftd_volume_score=30.0,
            ftd_trend_score=20.0,
            t35_proximity_score=15.0,
            price_momentum_score=10.0,
            current_ftd=500000,
            avg_ftd=200000.0,
            ftd_spike_ratio=2.5,
            days_to_t35=7,
            ftd_as_pct_of_volume=0.8,
            action='LONG',
            entry_price=25.00,
            stop_price=24.50,
            target_price=27.00,
            risk_reward_ratio=4.0,
            reasoning=['FTD SPIKE: 2.5x above average'],
            warnings=['Low absolute FTD count'],
            ftd_history=[{'date': '2025-12-15', 'quantity': 500000, 'price': 25.00}]
        )
        
        self.assertEqual(signal.symbol, 'GME')
        self.assertEqual(signal.signal_type, 'SPIKE')
        self.assertEqual(signal.score, 75.0)
        self.assertEqual(signal.current_ftd, 500000)
        self.assertEqual(signal.action, 'LONG')
        self.assertIsInstance(signal.reasoning, list)
        self.assertIsInstance(signal.warnings, list)
    
    def test_ftd_signal_types(self):
        """Test all valid signal types."""
        valid_types = ['ACCUMULATION', 'T35_WINDOW', 'SPIKE', 'COVERING_PRESSURE']
        
        for sig_type in valid_types:
            signal = FTDSignal(
                symbol='TEST',
                timestamp=datetime.now(),
                signal_type=sig_type,
                score=60.0,
                ftd_volume_score=20.0,
                ftd_trend_score=15.0,
                t35_proximity_score=15.0,
                price_momentum_score=10.0,
                current_ftd=100000,
                avg_ftd=50000.0,
                ftd_spike_ratio=2.0,
                days_to_t35=10,
                ftd_as_pct_of_volume=0.5,
                action='LONG',
                entry_price=10.00,
                stop_price=9.80,
                target_price=10.80,
                risk_reward_ratio=4.0,
                reasoning=[],
                warnings=[],
                ftd_history=[]
            )
            self.assertEqual(signal.signal_type, sig_type)


class TestFTDAnalyzerConstants(unittest.TestCase):
    """Test FTDAnalyzer constants and configuration."""
    
    def setUp(self):
        self.mock_client = MockChartExchangeClient()
        self.analyzer = FTDAnalyzer(self.mock_client)
    
    def test_signal_threshold(self):
        """Test signal threshold is set correctly."""
        self.assertEqual(self.analyzer.SIGNAL_THRESHOLD, 60)
    
    def test_score_weights_sum_to_100(self):
        """Test that max score weights sum to 100."""
        total = (
            self.analyzer.MAX_FTD_VOLUME_SCORE +
            self.analyzer.MAX_FTD_TREND_SCORE +
            self.analyzer.MAX_T35_PROXIMITY_SCORE +
            self.analyzer.MAX_MOMENTUM_SCORE
        )
        self.assertEqual(total, 100)
    
    def test_ftd_thresholds(self):
        """Test FTD thresholds are reasonable."""
        self.assertGreater(self.analyzer.FTD_SPIKE_THRESHOLD, 1.0)
        self.assertGreater(self.analyzer.FTD_SIGNIFICANT_THRESHOLD, 1.0)
        self.assertLess(self.analyzer.FTD_SIGNIFICANT_THRESHOLD, self.analyzer.FTD_SPIKE_THRESHOLD)
    
    def test_t35_window_thresholds(self):
        """Test T+35 window thresholds are reasonable."""
        self.assertLess(self.analyzer.T35_CRITICAL_DAYS, self.analyzer.T35_WARNING_DAYS)
        self.assertGreater(self.analyzer.T35_CRITICAL_DAYS, 0)
        self.assertLessEqual(self.analyzer.T35_WARNING_DAYS, 35)
    
    def test_trade_parameters(self):
        """Test trade parameters are reasonable."""
        self.assertGreater(self.analyzer.DEFAULT_TARGET_PCT, 0)
        self.assertGreater(self.analyzer.MIN_STOP_PCT, 0)
        self.assertGreater(self.analyzer.MIN_RR_RATIO, 1.0)


class TestFTDMetricsCalculation(unittest.TestCase):
    """Test FTD metrics calculation."""
    
    def setUp(self):
        self.mock_client = MockChartExchangeClient()
        self.analyzer = FTDAnalyzer(self.mock_client)
    
    def test_metrics_with_empty_data(self):
        """Test metrics calculation with empty FTD data."""
        metrics = self.analyzer._calculate_ftd_metrics([], None)
        
        self.assertEqual(metrics['current_ftd'], 0)
        self.assertEqual(metrics['avg_ftd'], 0)
        self.assertEqual(metrics['ftd_spike_ratio'], 0)
        self.assertEqual(metrics['ftd_trend'], 0)
        self.assertEqual(metrics['days_to_t35'], 35)
        self.assertEqual(metrics['ftd_as_pct_volume'], 0)
        self.assertFalse(metrics.get('has_ftd_data', True))
    
    def test_metrics_with_all_zeros(self):
        """Test metrics calculation when all FTD quantities are zero."""
        ftd_data = [
            {'date': '2025-12-15', 'quantity': 0, 'price': 25.00},
            {'date': '2025-12-14', 'quantity': 0, 'price': 24.50},
            {'date': '2025-12-13', 'quantity': 0, 'price': 24.00},
        ]
        
        metrics = self.analyzer._calculate_ftd_metrics(ftd_data, 10000000)
        
        self.assertEqual(metrics['current_ftd'], 0)
        self.assertEqual(metrics['avg_ftd'], 0)
        self.assertFalse(metrics.get('has_ftd_data', True))
    
    def test_metrics_with_valid_data(self):
        """Test metrics calculation with valid FTD data."""
        ftd_data = [
            {'date': '2025-12-15', 'quantity': 500000, 'price': 25.00},
            {'date': '2025-12-14', 'quantity': 300000, 'price': 24.50},
            {'date': '2025-12-13', 'quantity': 200000, 'price': 24.00},
            {'date': '2025-12-12', 'quantity': 250000, 'price': 23.50},
            {'date': '2025-12-11', 'quantity': 150000, 'price': 23.00},
        ]
        
        metrics = self.analyzer._calculate_ftd_metrics(ftd_data, 10000000)
        
        self.assertEqual(metrics['current_ftd'], 500000)
        self.assertGreater(metrics['avg_ftd'], 0)
        self.assertGreater(metrics['ftd_spike_ratio'], 0)
        self.assertTrue(metrics.get('has_ftd_data', False))
    
    def test_spike_ratio_calculation(self):
        """Test FTD spike ratio is calculated correctly."""
        # Create data where current FTD is 3x average
        ftd_data = [
            {'date': '2025-12-15', 'quantity': 300000, 'price': 25.00},  # Current: 300k
            {'date': '2025-12-14', 'quantity': 100000, 'price': 24.50},  # Avg: ~100k
            {'date': '2025-12-13', 'quantity': 100000, 'price': 24.00},
            {'date': '2025-12-12', 'quantity': 100000, 'price': 23.50},
            {'date': '2025-12-11', 'quantity': 100000, 'price': 23.00},
        ]
        
        metrics = self.analyzer._calculate_ftd_metrics(ftd_data, 10000000)
        
        # Spike ratio should be around 2.14 (300k / 140k avg)
        self.assertGreater(metrics['ftd_spike_ratio'], 1.5)
        self.assertLess(metrics['ftd_spike_ratio'], 3.0)
    
    def test_ftd_as_pct_of_volume(self):
        """Test FTD as percentage of volume calculation."""
        ftd_data = [
            {'date': '2025-12-15', 'quantity': 500000, 'price': 25.00},
        ]
        
        # 500k FTDs / 10M volume = 5%
        metrics = self.analyzer._calculate_ftd_metrics(ftd_data, 10000000)
        
        self.assertAlmostEqual(metrics['ftd_as_pct_volume'], 5.0, places=1)


class TestFTDScoreCalculation(unittest.TestCase):
    """Test FTD score component calculations."""
    
    def setUp(self):
        self.mock_client = MockChartExchangeClient()
        self.analyzer = FTDAnalyzer(self.mock_client)
    
    def test_ftd_volume_score_high_spike(self):
        """Test FTD volume score for high spike ratio."""
        metrics = {'ftd_spike_ratio': 3.0}
        score = self.analyzer._calculate_ftd_volume_score(metrics)
        
        # 3x spike should give max score
        self.assertEqual(score, self.analyzer.MAX_FTD_VOLUME_SCORE)
    
    def test_ftd_volume_score_medium_spike(self):
        """Test FTD volume score for medium spike ratio."""
        metrics = {'ftd_spike_ratio': 2.0}
        score = self.analyzer._calculate_ftd_volume_score(metrics)
        
        # 2x spike should give 80% of max
        expected = self.analyzer.MAX_FTD_VOLUME_SCORE * 0.8
        self.assertEqual(score, expected)
    
    def test_ftd_volume_score_low_spike(self):
        """Test FTD volume score for low spike ratio."""
        metrics = {'ftd_spike_ratio': 1.0}
        score = self.analyzer._calculate_ftd_volume_score(metrics)
        
        # 1x (no spike) should give low score
        self.assertLess(score, self.analyzer.MAX_FTD_VOLUME_SCORE * 0.4)
    
    def test_ftd_trend_score_high_trend(self):
        """Test FTD trend score for high trend."""
        metrics = {'ftd_trend': 2.0}
        score = self.analyzer._calculate_ftd_trend_score(metrics)
        
        # 2x trend should give max score
        self.assertEqual(score, self.analyzer.MAX_FTD_TREND_SCORE)
    
    def test_ftd_trend_score_declining(self):
        """Test FTD trend score for declining trend."""
        metrics = {'ftd_trend': 0.5}
        score = self.analyzer._calculate_ftd_trend_score(metrics)
        
        # Declining trend should give low score
        self.assertEqual(score, self.analyzer.MAX_FTD_TREND_SCORE * 0.2)
    
    def test_t35_score_critical_window(self):
        """Test T+35 score for critical window."""
        metrics = {'days_to_t35': 3}
        score = self.analyzer._calculate_t35_score(metrics)
        
        # 3 days should give max score
        self.assertEqual(score, self.analyzer.MAX_T35_PROXIMITY_SCORE)
    
    def test_t35_score_far_away(self):
        """Test T+35 score for far away deadline."""
        metrics = {'days_to_t35': 30}
        score = self.analyzer._calculate_t35_score(metrics)
        
        # 30 days should give low score
        self.assertEqual(score, self.analyzer.MAX_T35_PROXIMITY_SCORE * 0.1)


class TestFTDSignalTypeDetection(unittest.TestCase):
    """Test FTD signal type detection logic."""
    
    def setUp(self):
        self.mock_client = MockChartExchangeClient()
        self.analyzer = FTDAnalyzer(self.mock_client)
    
    def test_t35_window_signal(self):
        """Test T35_WINDOW signal detection."""
        metrics = {
            'days_to_t35': 3,  # Critical window
            'ftd_spike_ratio': 1.5,
            'ftd_trend': 1.2
        }
        
        signal_type = self.analyzer._determine_signal_type(metrics, 70)
        self.assertEqual(signal_type, 'T35_WINDOW')
    
    def test_spike_signal(self):
        """Test SPIKE signal detection."""
        metrics = {
            'days_to_t35': 20,  # Not in T35 window
            'ftd_spike_ratio': 2.5,  # Above spike threshold
            'ftd_trend': 1.2
        }
        
        signal_type = self.analyzer._determine_signal_type(metrics, 70)
        self.assertEqual(signal_type, 'SPIKE')
    
    def test_covering_pressure_signal(self):
        """Test COVERING_PRESSURE signal detection."""
        metrics = {
            'days_to_t35': 20,  # Not in T35 window
            'ftd_spike_ratio': 1.6,  # Below spike but above significant
            'ftd_trend': 1.6  # Rising trend
        }
        
        signal_type = self.analyzer._determine_signal_type(metrics, 70)
        self.assertEqual(signal_type, 'COVERING_PRESSURE')
    
    def test_accumulation_signal(self):
        """Test ACCUMULATION signal detection."""
        metrics = {
            'days_to_t35': 25,  # Not in T35 window
            'ftd_spike_ratio': 1.3,  # Below thresholds
            'ftd_trend': 1.1  # Slight trend
        }
        
        signal_type = self.analyzer._determine_signal_type(metrics, 60)
        self.assertEqual(signal_type, 'ACCUMULATION')


class TestFTDAnalyzerAnalyze(unittest.TestCase):
    """Test FTDAnalyzer.analyze() method."""
    
    def test_analyze_insufficient_data(self):
        """Test analyze returns None with insufficient data."""
        # Less than 5 records
        mock_client = MockChartExchangeClient(ftd_data=[
            {'date': '2025-12-15', 'quantity': 100000, 'price': 25.00},
            {'date': '2025-12-14', 'quantity': 100000, 'price': 24.50},
        ])
        
        analyzer = FTDAnalyzer(mock_client)
        signal = analyzer.analyze('GME', current_price=25.00)
        
        self.assertIsNone(signal)
    
    def test_analyze_below_threshold(self):
        """Test analyze returns None when score below threshold."""
        # Data that will produce low score
        mock_client = MockChartExchangeClient(ftd_data=[
            {'date': '2025-12-15', 'quantity': 10000, 'price': 25.00},
            {'date': '2025-12-14', 'quantity': 10000, 'price': 24.50},
            {'date': '2025-12-13', 'quantity': 10000, 'price': 24.00},
            {'date': '2025-12-12', 'quantity': 10000, 'price': 23.50},
            {'date': '2025-12-11', 'quantity': 10000, 'price': 23.00},
        ])
        
        analyzer = FTDAnalyzer(mock_client)
        
        # Mock price and volume fetching
        with patch.object(analyzer, '_get_current_price', return_value=25.00):
            with patch.object(analyzer, '_get_avg_daily_volume', return_value=10000000):
                with patch.object(analyzer, '_calculate_momentum_score', return_value=5.0):
                    signal = analyzer.analyze('GME')
        
        # Low FTD values should produce score below threshold
        self.assertIsNone(signal)
    
    def test_analyze_generates_signal(self):
        """Test analyze generates signal with good data."""
        # Data that will produce high score
        mock_client = MockChartExchangeClient(ftd_data=[
            {'date': '2025-12-15', 'quantity': 1000000, 'price': 25.00},
            {'date': '2025-12-14', 'quantity': 300000, 'price': 24.50},
            {'date': '2025-12-13', 'quantity': 200000, 'price': 24.00},
            {'date': '2025-12-12', 'quantity': 150000, 'price': 23.50},
            {'date': '2025-12-11', 'quantity': 100000, 'price': 23.00},
            {'date': '2025-12-10', 'quantity': 80000, 'price': 22.50},
        ])
        
        analyzer = FTDAnalyzer(mock_client)
        
        # Mock price and volume fetching
        with patch.object(analyzer, '_get_current_price', return_value=25.00):
            with patch.object(analyzer, '_get_avg_daily_volume', return_value=5000000):
                with patch.object(analyzer, '_calculate_momentum_score', return_value=12.0):
                    signal = analyzer.analyze('GME')
        
        # High FTD spike should produce signal
        if signal:
            self.assertIsInstance(signal, FTDSignal)
            self.assertEqual(signal.symbol, 'GME')
            self.assertEqual(signal.action, 'LONG')
            self.assertGreater(signal.score, 0)
            self.assertGreater(signal.entry_price, 0)
            self.assertLess(signal.stop_price, signal.entry_price)
            self.assertGreater(signal.target_price, signal.entry_price)


class TestFTDCandidateScanning(unittest.TestCase):
    """Test FTD candidate scanning functionality."""
    
    def test_get_ftd_candidates_empty(self):
        """Test get_ftd_candidates with no qualifying candidates."""
        mock_client = MockChartExchangeClient(ftd_data=[])
        analyzer = FTDAnalyzer(mock_client)
        
        candidates = analyzer.get_ftd_candidates(['GME', 'AMC'], min_score=50)
        
        self.assertEqual(len(candidates), 0)
    
    def test_get_ftd_candidates_sorting(self):
        """Test that candidates are sorted by score."""
        mock_client = MockChartExchangeClient()
        analyzer = FTDAnalyzer(mock_client)
        
        # Create mock signals
        signal1 = FTDSignal(
            symbol='GME', timestamp=datetime.now(), signal_type='SPIKE',
            score=70.0, ftd_volume_score=25.0, ftd_trend_score=20.0,
            t35_proximity_score=15.0, price_momentum_score=10.0,
            current_ftd=500000, avg_ftd=200000.0, ftd_spike_ratio=2.5,
            days_to_t35=7, ftd_as_pct_of_volume=0.8, action='LONG',
            entry_price=25.00, stop_price=24.50, target_price=27.00,
            risk_reward_ratio=4.0, reasoning=[], warnings=[], ftd_history=[]
        )
        
        signal2 = FTDSignal(
            symbol='AMC', timestamp=datetime.now(), signal_type='ACCUMULATION',
            score=85.0, ftd_volume_score=30.0, ftd_trend_score=25.0,
            t35_proximity_score=20.0, price_momentum_score=10.0,
            current_ftd=800000, avg_ftd=300000.0, ftd_spike_ratio=2.7,
            days_to_t35=5, ftd_as_pct_of_volume=1.2, action='LONG',
            entry_price=5.00, stop_price=4.90, target_price=5.40,
            risk_reward_ratio=4.0, reasoning=[], warnings=[], ftd_history=[]
        )
        
        # Mock analyze to return these signals
        with patch.object(analyzer, 'analyze', side_effect=[signal1, signal2]):
            candidates = analyzer.get_ftd_candidates(['GME', 'AMC'], min_score=50)
        
        # Should be sorted by score (highest first)
        self.assertEqual(len(candidates), 2)
        self.assertEqual(candidates[0].symbol, 'AMC')  # 85 > 70
        self.assertEqual(candidates[1].symbol, 'GME')


class TestT35Calendar(unittest.TestCase):
    """Test T+35 calendar functionality."""
    
    def test_t35_calendar_empty(self):
        """Test T+35 calendar with no FTD data."""
        mock_client = MockChartExchangeClient(ftd_data=[])
        analyzer = FTDAnalyzer(mock_client)
        
        calendar = analyzer.get_t35_calendar(['GME', 'AMC'])
        
        self.assertEqual(len(calendar), 0)
    
    def test_t35_calendar_filters_past_dates(self):
        """Test that T+35 calendar filters out past deadlines."""
        # Create FTD data from 40 days ago (T+35 already passed)
        old_date = (datetime.now() - timedelta(days=40)).strftime('%Y-%m-%d')
        
        mock_client = MockChartExchangeClient(ftd_data=[
            {'date': old_date, 'quantity': 100000, 'price': 25.00},
        ])
        
        analyzer = FTDAnalyzer(mock_client)
        calendar = analyzer.get_t35_calendar(['GME'])
        
        # Should not include past T+35 dates
        self.assertEqual(len(calendar), 0)
    
    def test_t35_calendar_sorting(self):
        """Test that T+35 calendar is sorted by days_until."""
        # Create FTD data with different dates
        date1 = (datetime.now() - timedelta(days=20)).strftime('%Y-%m-%d')  # T+35 in 15 days
        date2 = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')  # T+35 in 5 days
        
        mock_client = MockChartExchangeClient(ftd_data=[
            {'date': date1, 'quantity': 100000, 'price': 25.00},
            {'date': date2, 'quantity': 200000, 'price': 24.00},
        ])
        
        analyzer = FTDAnalyzer(mock_client)
        calendar = analyzer.get_t35_calendar(['GME'])
        
        if len(calendar) >= 2:
            # Should be sorted by days_until (closest first)
            self.assertLessEqual(calendar[0]['days_until'], calendar[1]['days_until'])


class TestFTDAnalyzerIntegration(unittest.TestCase):
    """Integration tests for FTD Analyzer with UnifiedAlphaMonitor."""
    
    def test_analyzer_initialization(self):
        """Test that analyzer can be initialized with a client."""
        mock_client = MockChartExchangeClient()
        analyzer = FTDAnalyzer(mock_client)
        
        self.assertIsNotNone(analyzer)
        self.assertEqual(analyzer.client, mock_client)
    
    def test_analyzer_with_real_client_structure(self):
        """Test analyzer works with client that has expected interface."""
        mock_client = Mock()
        mock_client.get_failure_to_deliver.return_value = []
        
        analyzer = FTDAnalyzer(mock_client)
        
        # Should not crash
        signal = analyzer.analyze('GME', current_price=25.00)
        
        # Should return None with empty data
        self.assertIsNone(signal)


class TestFTDAnalyzerEdgeCases(unittest.TestCase):
    """Test edge cases and error handling."""
    
    def setUp(self):
        self.mock_client = MockChartExchangeClient()
        self.analyzer = FTDAnalyzer(self.mock_client)
    
    def test_invalid_quantity_handling(self):
        """Test handling of invalid quantity values."""
        ftd_data = [
            {'date': '2025-12-15', 'quantity': 'invalid', 'price': 25.00},
            {'date': '2025-12-14', 'quantity': None, 'price': 24.50},
            {'date': '2025-12-13', 'quantity': 100000, 'price': 24.00},
            {'date': '2025-12-12', 'quantity': 100000, 'price': 23.50},
            {'date': '2025-12-11', 'quantity': 100000, 'price': 23.00},
        ]
        
        # Should not crash
        metrics = self.analyzer._calculate_ftd_metrics(ftd_data, 10000000)
        
        self.assertIsNotNone(metrics)
    
    def test_zero_volume_handling(self):
        """Test handling of zero average volume."""
        ftd_data = [
            {'date': '2025-12-15', 'quantity': 100000, 'price': 25.00},
        ]
        
        # Zero volume should not cause division error
        metrics = self.analyzer._calculate_ftd_metrics(ftd_data, 0)
        
        self.assertEqual(metrics['ftd_as_pct_volume'], 0)
    
    def test_missing_date_field(self):
        """Test handling of missing date field in FTD data."""
        ftd_data = [
            {'quantity': 100000, 'price': 25.00},  # Missing date
            {'date': '2025-12-14', 'quantity': 100000, 'price': 24.50},
            {'date': '2025-12-13', 'quantity': 100000, 'price': 24.00},
            {'date': '2025-12-12', 'quantity': 100000, 'price': 23.50},
            {'date': '2025-12-11', 'quantity': 100000, 'price': 23.00},
        ]
        
        # Should not crash
        metrics = self.analyzer._calculate_ftd_metrics(ftd_data, 10000000)
        
        self.assertIsNotNone(metrics)


def run_tests():
    """Run all tests and print summary."""
    print("=" * 70)
    print("üìà FTD ANALYZER TEST SUITE - Phase 4 Exploitation Module")
    print("=" * 70)
    print()
    
    # Create test suite
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    # Add all test classes
    test_classes = [
        TestFTDSignalDataclass,
        TestFTDAnalyzerConstants,
        TestFTDMetricsCalculation,
        TestFTDScoreCalculation,
        TestFTDSignalTypeDetection,
        TestFTDAnalyzerAnalyze,
        TestFTDCandidateScanning,
        TestT35Calendar,
        TestFTDAnalyzerIntegration,
        TestFTDAnalyzerEdgeCases,
    ]
    
    for test_class in test_classes:
        tests = loader.loadTestsFromTestCase(test_class)
        suite.addTests(tests)
    
    # Run tests
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # Print summary
    print()
    print("=" * 70)
    print("üìä TEST SUMMARY")
    print("=" * 70)
    print(f"   Tests Run: {result.testsRun}")
    print(f"   Failures: {len(result.failures)}")
    print(f"   Errors: {len(result.errors)}")
    print(f"   Skipped: {len(result.skipped)}")
    print()
    
    if result.wasSuccessful():
        print("‚úÖ ALL TESTS PASSED! üéâ")
    else:
        print("‚ùå SOME TESTS FAILED")
        
        if result.failures:
            print("\nüìã FAILURES:")
            for test, traceback in result.failures:
                print(f"   - {test}: {traceback.split(chr(10))[0]}")
        
        if result.errors:
            print("\nüìã ERRORS:")
            for test, traceback in result.errors:
                print(f"   - {test}: {traceback.split(chr(10))[0]}")
    
    print("=" * 70)
    
    return result.wasSuccessful()


if __name__ == '__main__':
    success = run_tests()
    sys.exit(0 if success else 1)

