#!/usr/bin/env python3
"""
ğŸ”¥ EXPLOIT NEWS NOW - Real-time news divergence detection

This script:
1. Gets REAL-TIME news sentiment (FREE - no API keys needed)
2. Gets dark pool institutional flow (ChartExchange)
3. Detects DIVERGENCES between news and institutional flow
4. Generates actionable signals

Works 24/7 - pre-market, market hours, post-market!
"""

import sys
import os
import logging
from datetime import datetime, timedelta
from pathlib import Path

# Setup paths
sys.path.append(str(Path(__file__).parent))
sys.path.append(str(Path(__file__).parent / 'live_monitoring' / 'enrichment'))
sys.path.append(str(Path(__file__).parent / 'live_monitoring' / 'enrichment' / 'apis'))
sys.path.append(str(Path(__file__).parent / 'live_monitoring' / 'core'))
sys.path.append(str(Path(__file__).parent / 'core'))
sys.path.append(str(Path(__file__).parent / 'core' / 'data'))
sys.path.append(str(Path(__file__).parent / 'configs'))

logging.basicConfig(
    level=logging.WARNING,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def get_news_sentiment():
    """Get current news sentiment using FREE RSS feeds"""
    from free_news import FreeNewsFetcher
    
    fetcher = FreeNewsFetcher()
    
    # Get overall market sentiment
    market_sentiment = fetcher.get_market_sentiment()
    
    # Get SPY specific sentiment
    spy_sentiment = fetcher.get_ticker_sentiment("SPY")
    
    return {
        "market": market_sentiment,
        "spy": spy_sentiment
    }


def get_institutional_flow(symbol: str = "SPY"):
    """Get dark pool institutional flow"""
    import yfinance as yf
    
    result = {
        "dp_pct": None,
        "dp_volume": 0,
        "total_volume": 0,
        "price": None,
        "daily_change": None,
        "institutional_bias": "NEUTRAL"
    }
    
    # Get price data
    ticker = yf.Ticker(symbol)
    hist = ticker.history(period="2d", interval="1d")
    
    if not hist.empty:
        result["price"] = float(hist['Close'].iloc[-1])
        result["total_volume"] = int(hist['Volume'].iloc[-1])
        
        if len(hist) > 1:
            prev_close = float(hist['Close'].iloc[-2])
            result["daily_change"] = ((result["price"] / prev_close) - 1) * 100
    
    # Get dark pool data
    try:
        from configs.chartexchange_config import get_api_key
        from core.data.ultimate_chartexchange_client import UltimateChartExchangeClient
        
        api_key = get_api_key()
        client = UltimateChartExchangeClient(api_key=api_key, tier=3)
        
        # Use yesterday's date for most complete DP data
        yesterday = (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d")
        
        # Skip weekends
        while datetime.strptime(yesterday, "%Y-%m-%d").weekday() >= 5:
            yesterday = (datetime.strptime(yesterday, "%Y-%m-%d") - timedelta(days=1)).strftime("%Y-%m-%d")
        
        dp_levels = client.get_dark_pool_levels(symbol, yesterday)
        dp_prints = client.get_dark_pool_prints(symbol, yesterday)
        
        dp_vol = 0
        if dp_levels:
            for level in dp_levels:
                if isinstance(level, dict) and 'volume' in level:
                    dp_vol += int(level['volume'])
        
        if dp_vol == 0 and dp_prints:
            for print_obj in dp_prints:
                if isinstance(print_obj, dict) and 'size' in print_obj:
                    dp_vol += int(print_obj['size'])
        
        result["dp_volume"] = dp_vol
        
        if result["total_volume"] > 0:
            result["dp_pct"] = (dp_vol / result["total_volume"]) * 100
            
            # Determine institutional bias
            if result["dp_pct"] > 45:
                result["institutional_bias"] = "ACCUMULATING"
            elif result["dp_pct"] < 25:
                result["institutional_bias"] = "DISTRIBUTING"
            else:
                result["institutional_bias"] = "NEUTRAL"
        
    except Exception as e:
        logger.error(f"Error getting DP data: {e}")
    
    return result


def detect_divergence(news_sentiment: dict, institutional_flow: dict):
    """
    Detect divergence between news sentiment and institutional flow
    
    DIVERGENCE = When institutions do OPPOSITE of what news suggests
    
    Returns:
    {
        "divergence_detected": bool,
        "signal": "BUY" | "SELL" | "HOLD",
        "confidence": float,
        "reasoning": [str],
        "entry": float,
        "stop_loss": float,
        "target": float
    }
    """
    result = {
        "divergence_detected": False,
        "signal": "HOLD",
        "confidence": 0.40,
        "reasoning": [],
        "entry": None,
        "stop_loss": None,
        "target": None
    }
    
    market_sent = news_sentiment.get("market", {}).get("sentiment", "NEUTRAL")
    spy_sent = news_sentiment.get("spy", {}).get("sentiment", "NEUTRAL")
    news_confidence = news_sentiment.get("market", {}).get("confidence", 0)
    
    inst_bias = institutional_flow.get("institutional_bias", "NEUTRAL")
    dp_pct = institutional_flow.get("dp_pct")
    price = institutional_flow.get("price", 0)
    daily_change = institutional_flow.get("daily_change", 0)
    
    if dp_pct is None:
        result["reasoning"].append("âš ï¸ No dark pool data available")
        return result
    
    # =====================================================
    # DIVERGENCE DETECTION RULES
    # =====================================================
    
    # CASE 1: News BEARISH + Institutions ACCUMULATING = BUY
    if market_sent == "BEARISH" and inst_bias == "ACCUMULATING":
        result["divergence_detected"] = True
        result["signal"] = "BUY"
        result["confidence"] = 0.75 + (news_confidence * 0.1)
        result["reasoning"].append(f"ğŸ¯ DIVERGENCE: News is BEARISH but institutions are ACCUMULATING")
        result["reasoning"].append(f"   News sentiment: {market_sent} (confidence: {news_confidence:.0%})")
        result["reasoning"].append(f"   Dark Pool: {dp_pct:.1f}% (>{45}% = accumulation)")
        result["reasoning"].append(f"   â†’ Institutions buying while retail panics")
    
    # CASE 2: News BULLISH + Institutions DISTRIBUTING = SELL
    elif market_sent == "BULLISH" and inst_bias == "DISTRIBUTING":
        result["divergence_detected"] = True
        result["signal"] = "SELL"
        result["confidence"] = 0.75 + (news_confidence * 0.1)
        result["reasoning"].append(f"ğŸ¯ DIVERGENCE: News is BULLISH but institutions are DISTRIBUTING")
        result["reasoning"].append(f"   News sentiment: {market_sent} (confidence: {news_confidence:.0%})")
        result["reasoning"].append(f"   Dark Pool: {dp_pct:.1f}% (<{25}% = distribution)")
        result["reasoning"].append(f"   â†’ Institutions selling while retail FOMOs")
    
    # CASE 3: Price DOWN + News BEARISH + Institutions ACCUMULATING = STRONG BUY
    elif daily_change and daily_change < -0.5 and inst_bias == "ACCUMULATING":
        result["divergence_detected"] = True
        result["signal"] = "BUY"
        result["confidence"] = 0.80
        result["reasoning"].append(f"ğŸ”¥ STRONG DIVERGENCE: Price DOWN but institutions ACCUMULATING")
        result["reasoning"].append(f"   Price change: {daily_change:.2f}%")
        result["reasoning"].append(f"   Dark Pool: {dp_pct:.1f}% (accumulation)")
        result["reasoning"].append(f"   â†’ Classic 'buy the dip' setup")
    
    # CASE 4: Price UP + News BULLISH + Institutions DISTRIBUTING = STRONG SELL
    elif daily_change and daily_change > 0.5 and inst_bias == "DISTRIBUTING":
        result["divergence_detected"] = True
        result["signal"] = "SELL"
        result["confidence"] = 0.80
        result["reasoning"].append(f"ğŸ”¥ STRONG DIVERGENCE: Price UP but institutions DISTRIBUTING")
        result["reasoning"].append(f"   Price change: {daily_change:.2f}%")
        result["reasoning"].append(f"   Dark Pool: {dp_pct:.1f}% (distribution)")
        result["reasoning"].append(f"   â†’ Classic 'sell the rip' setup")
    
    # CASE 5: Stealth accumulation (neutral news but high DP)
    elif market_sent == "NEUTRAL" and inst_bias == "ACCUMULATING":
        result["divergence_detected"] = True
        result["signal"] = "BUY"
        result["confidence"] = 0.65
        result["reasoning"].append(f"ğŸ‘€ STEALTH ACCUMULATION: Neutral news but institutions loading")
        result["reasoning"].append(f"   Dark Pool: {dp_pct:.1f}% (high)")
        result["reasoning"].append(f"   â†’ Quiet accumulation before news breaks")
    
    # CASE 6: Stealth distribution (neutral news but low DP)
    elif market_sent == "NEUTRAL" and inst_bias == "DISTRIBUTING":
        result["divergence_detected"] = True
        result["signal"] = "SELL"
        result["confidence"] = 0.65
        result["reasoning"].append(f"ğŸ‘€ STEALTH DISTRIBUTION: Neutral news but institutions unloading")
        result["reasoning"].append(f"   Dark Pool: {dp_pct:.1f}% (low)")
        result["reasoning"].append(f"   â†’ Quiet distribution before news breaks")
    
    # NO DIVERGENCE
    else:
        result["reasoning"].append(f"ğŸ“Š No divergence detected")
        result["reasoning"].append(f"   News: {market_sent}, Institutions: {inst_bias}")
        result["reasoning"].append(f"   Dark Pool: {dp_pct:.1f}% (neutral range)")
    
    # Calculate entry/stop/target if signal generated
    if result["signal"] != "HOLD" and price:
        result["entry"] = price
        if result["signal"] == "BUY":
            result["stop_loss"] = price * 0.98  # 2% stop
            result["target"] = price * 1.02     # 2% target
        else:  # SELL
            result["stop_loss"] = price * 1.02
            result["target"] = price * 0.98
    
    return result


def main():
    """Run the news exploit analysis"""
    print("=" * 80)
    print("ğŸ”¥ NEWS EXPLOIT NOW - Real-time Divergence Detection")
    print(f"   Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 80)
    
    symbol = "SPY"
    
    # Step 1: Get news sentiment
    print("\nğŸ“° FETCHING NEWS SENTIMENT...")
    print("-" * 40)
    news = get_news_sentiment()
    
    market_sent = news["market"]
    spy_sent = news["spy"]
    
    print(f"   Market Sentiment: {market_sent['sentiment']} ({market_sent['confidence']:.0%} confidence)")
    print(f"   SPY Sentiment: {spy_sent['sentiment']}")
    print(f"   Total Articles: {market_sent['total_articles']}")
    print(f"   Bullish: {market_sent['bullish_count']} | Bearish: {market_sent['bearish_count']}")
    
    if market_sent.get('top_bullish_headlines'):
        print("\n   ğŸ“ˆ Top Bullish Headlines:")
        for h in market_sent['top_bullish_headlines'][:2]:
            print(f"      â€¢ {h[:60]}...")
    
    if market_sent.get('top_bearish_headlines'):
        print("\n   ğŸ“‰ Top Bearish Headlines:")
        for h in market_sent['top_bearish_headlines'][:2]:
            print(f"      â€¢ {h[:60]}...")
    
    # Step 2: Get institutional flow
    print("\n" + "-" * 40)
    print("ğŸ¦ FETCHING INSTITUTIONAL FLOW...")
    print("-" * 40)
    institutional = get_institutional_flow(symbol)
    
    print(f"   {symbol} Price: ${institutional['price']:.2f}" if institutional['price'] else "   Price: N/A")
    print(f"   Daily Change: {institutional['daily_change']:+.2f}%" if institutional['daily_change'] else "   Daily Change: N/A")
    print(f"   Dark Pool %: {institutional['dp_pct']:.1f}%" if institutional['dp_pct'] else "   Dark Pool %: N/A")
    print(f"   Institutional Bias: {institutional['institutional_bias']}")
    
    # Step 3: Detect divergence
    print("\n" + "=" * 80)
    print("ğŸ¯ DIVERGENCE ANALYSIS")
    print("=" * 80)
    
    divergence = detect_divergence(news, institutional)
    
    if divergence["divergence_detected"]:
        print(f"\n   ğŸ”¥ DIVERGENCE DETECTED!")
        print(f"\n   Signal: {divergence['signal']}")
        print(f"   Confidence: {divergence['confidence']:.0%}")
        
        if divergence['entry']:
            print(f"\n   ğŸ“Š TRADE SETUP:")
            print(f"      Entry: ${divergence['entry']:.2f}")
            print(f"      Stop Loss: ${divergence['stop_loss']:.2f}")
            print(f"      Target: ${divergence['target']:.2f}")
    else:
        print(f"\n   ğŸ“Š No divergence detected")
    
    print(f"\n   ğŸ“ ANALYSIS:")
    for r in divergence['reasoning']:
        print(f"      {r}")
    
    # Summary
    print("\n" + "=" * 80)
    print("ğŸ“Š SUMMARY")
    print("=" * 80)
    
    print(f"""
   News Sentiment: {market_sent['sentiment']} ({market_sent['confidence']:.0%})
   Institutional Bias: {institutional['institutional_bias']}
   Dark Pool %: {institutional['dp_pct']:.1f}%
   
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SIGNAL: {divergence['signal']} @ {divergence['confidence']:.0%} confidence
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    if divergence["divergence_detected"]:
        print(f"   ğŸ”¥ ACTION: Take the {divergence['signal']} signal!")
        print(f"   Entry: ${divergence['entry']:.2f} | Stop: ${divergence['stop_loss']:.2f} | Target: ${divergence['target']:.2f}")
    else:
        print(f"   â¸ï¸  ACTION: No trade - wait for divergence")
    
    return divergence


if __name__ == "__main__":
    main()




