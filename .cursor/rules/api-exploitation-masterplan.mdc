# üî• API EXPLOITATION MASTERPLAN - FULL EXECUTION DOCTRINE

## What This Document Is

This is the **SINGLE SOURCE OF TRUTH** for how we exploit every goddamn API we have access to. No hallucination, no siloed modules that don't connect, no theoretical bullshit that can't be tested.

**Every feature described here:**
1. Has a clear data source (API endpoint)
2. Has a clear integration point (existing module)
3. Has a testable output (signal, alert, metric)
4. Has a validation method (backtest, paper trade, A/B test)

---

## üìä CURRENT SYSTEM ARCHITECTURE (What We Have)

Before we add anything, let's be fucking clear about what EXISTS and WORKS:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    CURRENT PRODUCTION SYSTEM                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                      ‚îÇ
‚îÇ  DATA SOURCES (WORKING):                                            ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ ChartExchange Tier 3 API                                       ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ /data/dark-pool-levels/ ‚úÖ USED                           ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ /data/dark-pool-prints/ ‚úÖ USED                           ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ /data/stocks/short-volume/ ‚ö†Ô∏è PARTIAL                    ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ /data/stocks/short-interest/ ‚ö†Ô∏è PARTIAL                  ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ /data/stocks/borrow-fee/ib/ ‚ùå NOT USED                   ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ /data/stocks/failure-to-deliver/ ‚ùå NOT USED              ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ /data/options/chain-summary/ ‚ö†Ô∏è PARTIAL                  ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ /data/stocks/exchange-volume-intraday/ ‚ö†Ô∏è PARTIAL        ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ /data/reddit/mentions/* ‚ö†Ô∏è PARTIAL                       ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ /screener/stocks/ ‚ö†Ô∏è PARTIAL                             ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ ALL OTHER ENDPOINTS ‚ùå NOT USED                           ‚îÇ
‚îÇ  ‚îÇ                                                                   ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Yahoo Finance API ‚úÖ USED                                      ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ Market quotes                                              ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ Historical data                                            ‚îÇ
‚îÇ  ‚îÇ                                                                   ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Trading Economics ‚úÖ NEW                                       ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ Economic calendar + forecasts                              ‚îÇ
‚îÇ  ‚îÇ                                                                   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Fed Watch / CME ‚ö†Ô∏è PARTIAL                                    ‚îÇ
‚îÇ      ‚îî‚îÄ‚îÄ Rate probabilities                                         ‚îÇ
‚îÇ                                                                      ‚îÇ
‚îÇ  PROCESSING (WORKING):                                              ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ UnifiedAlphaMonitor (orchestrator)                             ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ AlertManager (Discord + DB)                                ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ RegimeDetector (market regime)                             ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ MomentumDetector (selloff/rally)                          ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ MonitorInitializer (component setup)                       ‚îÇ
‚îÇ  ‚îÇ                                                                   ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Signal Generation                                              ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ Narrative Brain (synthesis)                                ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ DP Battleground Analysis                                   ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ Trade Calculator                                           ‚îÇ
‚îÇ  ‚îÇ                                                                   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Alerting                                                       ‚îÇ
‚îÇ      ‚îú‚îÄ‚îÄ Discord webhooks                                           ‚îÇ
‚îÇ      ‚îî‚îÄ‚îÄ Database logging                                           ‚îÇ
‚îÇ                                                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üéØ EXPLOITATION PHASES (Ordered by Impact + Effort)

### The Reality Check

Before we build ANYTHING new, we need to answer:

1. **Does the API endpoint actually return usable data?** (Test it)
2. **Where does this data plug into our existing system?** (Integration point)
3. **How do we validate it improves our edge?** (Backtest method)
4. **What's the minimum viable implementation?** (No over-engineering)

---

## PHASE 1: SHORT SQUEEZE DETECTION üöÄ

### Why This First?

- **High edge potential:** Squeezes are 10-50%+ moves
- **Clear data sources:** 3 ChartExchange endpoints we're NOT using
- **Existing integration point:** Already have signal generation pipeline
- **Easy to validate:** Historical squeeze events are well-documented (GME, AMC, etc.)

### Data Sources (All ChartExchange Tier 3)

| Endpoint | Data | Current Status |
|----------|------|----------------|
| `/data/stocks/short-interest/` | SI % of float | ‚ùå Not used |
| `/data/stocks/short-interest-daily/` | SI trend over time | ‚ùå Not used |
| `/data/stocks/borrow-fee/ib/` | Cost to borrow | ‚ùå Not used |
| `/data/stocks/failure-to-deliver/` | FTD data | ‚ùå Not used |

### Integration Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 SQUEEZE DETECTOR MODULE                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                ‚îÇ
‚îÇ  INPUT: Ticker (from screener or watchlist)                   ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  STEP 1: Fetch Short Data                                     ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ GET /data/stocks/short-interest/?symbol=US:{ticker}      ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ GET /data/stocks/borrow-fee/ib/?symbol=US:{ticker}       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ GET /data/stocks/failure-to-deliver/?symbol=US:{ticker}  ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  STEP 2: Calculate Squeeze Score (0-100)                      ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ short_interest_score = min(SI% / 30 * 100, 40)          ‚îÇ
‚îÇ  ‚îÇ   (30% SI = max 40 points)                                 ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ borrow_fee_score = min(borrow_fee / 100 * 100, 30)      ‚îÇ
‚îÇ  ‚îÇ   (100% borrow fee = max 30 points)                        ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ ftd_score = min(ftd_spike_ratio / 3 * 100, 20)          ‚îÇ
‚îÇ  ‚îÇ   (3x FTD spike = max 20 points)                           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ dp_support_score = dp_buying_pressure * 10              ‚îÇ
‚îÇ      (DP support = max 10 points)                             ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  STEP 3: Generate Signal if Score > 70                        ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ action = "LONG"                                          ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ entry = current_price                                    ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ stop = nearest_dp_support - 1%                          ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ target = current_price + (current_price * 0.10)         ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ confidence = squeeze_score                               ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  OUTPUT: SqueezeSignal ‚Üí AlertManager                         ‚îÇ
‚îÇ                                                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### File Structure

```
live_monitoring/
‚îî‚îÄ‚îÄ exploitation/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ squeeze_detector.py       # Main squeeze logic
    ‚îî‚îÄ‚îÄ short_data_fetcher.py     # API calls for short data
```

### Implementation Steps

**Step 1: Create API Fetcher (2 hours)**

File: `live_monitoring/exploitation/short_data_fetcher.py`

```python
"""
Short data fetcher - uses ChartExchange Tier 3 endpoints.
NO MOCK DATA. Returns None if API fails.
"""

class ShortDataFetcher:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.chartexchange.com"
        
    def get_short_interest(self, symbol: str) -> Optional[Dict]:
        """
        GET /data/stocks/short-interest/
        
        Returns:
            {
                'short_interest': 25.5,  # % of float
                'short_interest_ratio': 3.2,  # days to cover
                'date': '2024-01-15'
            }
        Or None if API fails.
        """
        # Implementation uses existing self._make_request pattern
        
    def get_borrow_fee(self, symbol: str) -> Optional[Dict]:
        """
        GET /data/stocks/borrow-fee/ib/
        
        Returns:
            {
                'borrow_fee': 45.5,  # annual % rate
                'available_shares': 150000,
                'date': '2024-01-15'
            }
        Or None if API fails.
        """
        
    def get_ftd_data(self, symbol: str, days: int = 30) -> Optional[List[Dict]]:
        """
        GET /data/stocks/failure-to-deliver/
        
        Returns list of FTD records.
        We calculate spike ratio ourselves.
        """
```

**Step 2: Create Squeeze Detector (3 hours)**

File: `live_monitoring/exploitation/squeeze_detector.py`

```python
"""
Squeeze detector - combines short data with DP levels.
ONLY generates signals when ALL data is available.
"""

@dataclass
class SqueezeSignal:
    symbol: str
    score: float  # 0-100
    short_interest: float
    borrow_fee: float
    ftd_spike_ratio: float
    dp_support: float
    action: str  # LONG
    entry: float
    stop: float
    target: float
    reasoning: List[str]
    timestamp: datetime

class SqueezeDetector:
    def __init__(self, short_fetcher: ShortDataFetcher, dp_client):
        self.short_fetcher = short_fetcher
        self.dp_client = dp_client
        
    def analyze(self, symbol: str) -> Optional[SqueezeSignal]:
        """
        Analyze a symbol for squeeze potential.
        Returns None if:
        - Any API call fails
        - Score < 70
        - No DP support found
        """
        # Fetch all data (fail fast if any missing)
        short_data = self.short_fetcher.get_short_interest(symbol)
        if not short_data:
            logger.debug(f"{symbol}: No short interest data")
            return None
            
        borrow_data = self.short_fetcher.get_borrow_fee(symbol)
        if not borrow_data:
            logger.debug(f"{symbol}: No borrow fee data")
            return None
            
        ftd_data = self.short_fetcher.get_ftd_data(symbol)
        if not ftd_data:
            logger.debug(f"{symbol}: No FTD data")
            return None
            
        # Get DP levels for stop placement
        dp_levels = self.dp_client.get_dark_pool_levels(symbol)
        if not dp_levels:
            logger.debug(f"{symbol}: No DP levels")
            return None
            
        # Calculate score
        score = self._calculate_squeeze_score(
            short_data, borrow_data, ftd_data, dp_levels
        )
        
        if score < 70:
            logger.debug(f"{symbol}: Score {score} < 70 threshold")
            return None
            
        # Generate signal
        return self._build_signal(symbol, score, short_data, borrow_data, ftd_data, dp_levels)
```

**Step 3: Integration with UnifiedAlphaMonitor (2 hours)**

Add to `live_monitoring/orchestrator/unified_monitor.py`:

```python
# In __init__:
self.squeeze_detector = None
try:
    from live_monitoring.exploitation.squeeze_detector import SqueezeDetector
    from live_monitoring.exploitation.short_data_fetcher import ShortDataFetcher
    short_fetcher = ShortDataFetcher(api_key)
    self.squeeze_detector = SqueezeDetector(short_fetcher, self.dp_client)
    self.squeeze_enabled = True
except ImportError as e:
    logger.warning(f"Squeeze detector not available: {e}")
    self.squeeze_enabled = False

# In main loop (run once per hour during RTH):
if self.squeeze_enabled and is_market_hours:
    if self.last_squeeze_check is None or (now - self.last_squeeze_check).seconds >= 3600:
        self._check_squeeze_candidates()
        self.last_squeeze_check = now

def _check_squeeze_candidates(self):
    """Check watchlist for squeeze setups."""
    watchlist = ['SPY', 'QQQ'] + self._get_high_short_interest_tickers()
    
    for symbol in watchlist:
        signal = self.squeeze_detector.analyze(symbol)
        if signal:
            self._send_squeeze_alert(signal)
```

### Testing Strategy

**Unit Tests (before integration):**

```python
# tests/exploitation/test_squeeze_detector.py

def test_short_data_fetcher_handles_api_failure():
    """Fetcher returns None on API error, doesn't crash."""
    
def test_squeeze_score_calculation():
    """Score calculation matches expected formula."""
    
def test_squeeze_detector_requires_all_data():
    """Detector returns None if any data source fails."""
    
def test_squeeze_signal_generation():
    """Signal has all required fields when score > 70."""
```

**Integration Tests (with real API):**

```python
# tests/exploitation/test_squeeze_integration.py

def test_real_api_short_interest():
    """Fetch real SI data for SPY."""
    fetcher = ShortDataFetcher(api_key=os.getenv('CHARTEXCHANGE_API_KEY'))
    data = fetcher.get_short_interest('SPY')
    assert data is not None or data is None  # Either works, no crash
    
def test_real_api_borrow_fee():
    """Fetch real borrow fee for SPY."""
    
def test_real_api_ftd():
    """Fetch real FTD data for SPY."""
```

**Validation (historical backtest):**

```python
# backtest_squeeze_signals.py

"""
Backtest squeeze signals on historical data.

Method:
1. Get list of known squeezes (GME Jan 2021, AMC June 2021, etc.)
2. Check if our detector would have caught them
3. Check for false positives (high score but no squeeze)
"""
```

### Success Criteria

| Metric | Target | Validation Method |
|--------|--------|-------------------|
| API Success Rate | >95% | Log API calls |
| Historical Squeeze Detection | >80% | Backtest known squeezes |
| False Positive Rate | <30% | Backtest non-squeeze high-SI stocks |
| Signal-to-Alert Latency | <5s | Measure in production |

---

## PHASE 2: OPTIONS FLOW INTELLIGENCE üí•

### Why This Second?

- **Already have partial implementation:** Options chain summary exists
- **Clear edge:** Gamma squeezes are predictable mechanics
- **Existing integration:** Can plug into regime detection

### Data Sources

| Endpoint | Data | Current Status |
|----------|------|----------------|
| `/data/options/chain-summary/` | Max pain, ITM/OTM | ‚ö†Ô∏è Partial |
| `/data/options/bars/` | Options OHLC | ‚ùå Not used |

### Integration Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 GAMMA TRACKER MODULE                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                ‚îÇ
‚îÇ  INPUT: Ticker (SPY, QQQ only for now)                        ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  STEP 1: Fetch Options Data                                   ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ GET /data/options/chain-summary/?symbol=US:{ticker}      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Parse: max_pain, total_call_oi, total_put_oi             ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  STEP 2: Calculate Gamma Metrics                              ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ put_call_ratio = total_put_oi / total_call_oi           ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ max_pain_distance = (max_pain - current_price) / price  ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ gamma_direction = UP if max_pain > price else DOWN      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ gamma_strength = abs(max_pain_distance) * call_oi_weight‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  STEP 3: Generate Signal if Conditions Met                    ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ IF put_call_ratio < 0.7 AND max_pain > price BY 1%+     ‚îÇ
‚îÇ  ‚îÇ   ‚Üí GAMMA RAMP LONG (dealers will buy to hedge)           ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ IF put_call_ratio > 1.3 AND max_pain < price BY 1%+     ‚îÇ
‚îÇ  ‚îÇ   ‚Üí GAMMA RAMP SHORT (dealers will sell to hedge)         ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ ELSE ‚Üí No gamma signal                                   ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  OUTPUT: GammaSignal ‚Üí Feed to RegimeDetector                 ‚îÇ
‚îÇ                                                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### File Structure

```
live_monitoring/
‚îî‚îÄ‚îÄ exploitation/
    ‚îú‚îÄ‚îÄ gamma_tracker.py          # Gamma exposure analysis
    ‚îî‚îÄ‚îÄ options_data_fetcher.py   # Options API calls
```

### Implementation Steps

**Step 1: Options Data Fetcher (1.5 hours)**

```python
# live_monitoring/exploitation/options_data_fetcher.py

class OptionsDataFetcher:
    def get_chain_summary(self, symbol: str, date: str = None) -> Optional[Dict]:
        """
        GET /data/options/chain-summary/
        
        Returns:
            {
                'max_pain': 665.0,
                'total_call_oi': 1500000,
                'total_put_oi': 1200000,
                'itm_call_oi': 300000,
                'otm_call_oi': 1200000,
                'expiration': '2024-01-19'
            }
        """
```

**Step 2: Gamma Tracker (2.5 hours)**

```python
# live_monitoring/exploitation/gamma_tracker.py

@dataclass
class GammaSignal:
    symbol: str
    direction: str  # UP, DOWN
    put_call_ratio: float
    max_pain: float
    max_pain_distance_pct: float
    strength: float  # 0-100
    reasoning: str
    timestamp: datetime

class GammaTracker:
    def __init__(self, options_fetcher: OptionsDataFetcher):
        self.options_fetcher = options_fetcher
        
    def analyze(self, symbol: str, current_price: float) -> Optional[GammaSignal]:
        """
        Analyze gamma exposure for a symbol.
        """
        summary = self.options_fetcher.get_chain_summary(symbol)
        if not summary:
            return None
            
        # Calculate metrics
        put_call_ratio = summary['total_put_oi'] / max(summary['total_call_oi'], 1)
        max_pain = summary['max_pain']
        max_pain_distance = (max_pain - current_price) / current_price
        
        # Check for gamma ramp conditions
        if put_call_ratio < 0.7 and max_pain_distance > 0.01:
            # Low P/C + max pain above = bullish gamma
            return GammaSignal(
                symbol=symbol,
                direction='UP',
                put_call_ratio=put_call_ratio,
                max_pain=max_pain,
                max_pain_distance_pct=max_pain_distance * 100,
                strength=min((0.7 - put_call_ratio) * 100 + max_pain_distance * 50, 100),
                reasoning=f"P/C {put_call_ratio:.2f} < 0.7, Max Pain ${max_pain:.2f} is {max_pain_distance*100:.1f}% above",
                timestamp=datetime.now()
            )
        elif put_call_ratio > 1.3 and max_pain_distance < -0.01:
            # High P/C + max pain below = bearish gamma
            return GammaSignal(
                symbol=symbol,
                direction='DOWN',
                put_call_ratio=put_call_ratio,
                max_pain=max_pain,
                max_pain_distance_pct=max_pain_distance * 100,
                strength=min((put_call_ratio - 1.3) * 100 + abs(max_pain_distance) * 50, 100),
                reasoning=f"P/C {put_call_ratio:.2f} > 1.3, Max Pain ${max_pain:.2f} is {abs(max_pain_distance)*100:.1f}% below",
                timestamp=datetime.now()
            )
            
        return None
```

**Step 3: Integration with RegimeDetector (1 hour)**

```python
# In regime_detector.py, add gamma as a factor:

def _detect_market_regime(self, current_price: float) -> str:
    # ... existing factors ...
    
    # Add gamma factor
    gamma_signal = self.gamma_tracker.analyze('SPY', current_price) if self.gamma_tracker else None
    if gamma_signal:
        if gamma_signal.direction == 'UP' and gamma_signal.strength > 50:
            bullish_signals += 1
            factors.append(f"Gamma: {gamma_signal.reasoning}")
        elif gamma_signal.direction == 'DOWN' and gamma_signal.strength > 50:
            bearish_signals += 1
            factors.append(f"Gamma: {gamma_signal.reasoning}")
```

### Testing Strategy

**Unit Tests:**
```python
def test_put_call_ratio_calculation():
    """P/C ratio correctly calculated."""
    
def test_gamma_signal_long_conditions():
    """Long signal generated when P/C < 0.7 and max pain above."""
    
def test_gamma_signal_short_conditions():
    """Short signal generated when P/C > 1.3 and max pain below."""
    
def test_no_signal_when_neutral():
    """No signal when conditions not met."""
```

**Validation:**
```python
# Track gamma signals vs actual price movement toward max pain
# Over 30 days, measure correlation
```

### Success Criteria

| Metric | Target | Validation Method |
|--------|--------|-------------------|
| Max Pain Correlation | >60% | Track price vs max pain over time |
| Signal Direction Accuracy | >55% | Compare predicted vs actual direction |
| Gamma Signal Win Rate | >55% | Backtest gamma-only signals |

---

## PHASE 3: MULTI-TICKER OPPORTUNITY SCANNER üîç

### Why This Third?

- **Expands opportunity pool:** Currently only SPY/QQQ
- **Screener API exists:** We're barely using it
- **Force multiplier:** Find setups we'd otherwise miss

### Data Sources

| Endpoint | Data | Current Status |
|----------|------|----------------|
| `/screener/stocks/` | Filter thousands of stocks | ‚ö†Ô∏è Partial |
| `/screener/stocks/columns/` | Available filter columns | ‚ùå Not used |

### Integration Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 OPPORTUNITY SCANNER MODULE                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                ‚îÇ
‚îÇ  RUN FREQUENCY: Once at market open, once at 2pm              ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  SCAN 1: High Short Interest                                  ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Filter: short_interest > 15%                            ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Filter: avg_volume > 1M                                 ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Filter: price > 10                                      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Output: Top 10 by short_interest                        ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  SCAN 2: Unusual Volume                                       ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Filter: volume_today > 3x avg_volume                    ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Filter: price > 5                                       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Output: Top 10 by volume_ratio                          ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  SCAN 3: Near Earnings (Volatility Play)                     ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Filter: days_to_earnings < 5                            ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Filter: avg_volume > 500K                               ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Output: Top 10 by days_to_earnings                      ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  FOR EACH RESULT:                                             ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Run through SqueezeDetector                             ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Run through GammaTracker                                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Run through DP analysis                                 ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  OUTPUT: Ranked opportunity list ‚Üí Morning report            ‚îÇ
‚îÇ                                                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### File Structure

```
live_monitoring/
‚îî‚îÄ‚îÄ exploitation/
    ‚îú‚îÄ‚îÄ opportunity_scanner.py    # Screener logic
    ‚îî‚îÄ‚îÄ watchlist_manager.py      # Dynamic watchlist
```

### Implementation Steps

**Step 1: Screener Integration (2 hours)**

```python
# live_monitoring/exploitation/opportunity_scanner.py

class OpportunityScanner:
    def __init__(self, api_key: str):
        self.api_key = api_key
        
    def scan_high_short_interest(self) -> List[Dict]:
        """
        GET /screener/stocks/?short_interest__gte=15&avg_volume__gte=1000000&price__gte=10
        """
        
    def scan_unusual_volume(self) -> List[Dict]:
        """
        GET /screener/stocks/?volume_ratio__gte=3&price__gte=5
        """
        
    def scan_near_earnings(self) -> List[Dict]:
        """
        GET /screener/stocks/?days_to_earnings__lte=5&avg_volume__gte=500000
        """
        
    def get_daily_opportunities(self) -> Dict[str, List]:
        """
        Run all scans and return categorized opportunities.
        """
        return {
            'high_short_interest': self.scan_high_short_interest()[:10],
            'unusual_volume': self.scan_unusual_volume()[:10],
            'near_earnings': self.scan_near_earnings()[:10]
        }
```

**Step 2: Watchlist Manager (1.5 hours)**

```python
# live_monitoring/exploitation/watchlist_manager.py

class WatchlistManager:
    """
    Manages dynamic watchlist based on scanner results.
    """
    def __init__(self):
        self.base_watchlist = ['SPY', 'QQQ']
        self.dynamic_watchlist = []
        
    def update_from_scanner(self, opportunities: Dict[str, List]):
        """
        Add top opportunities to watchlist for detailed monitoring.
        """
        new_tickers = set()
        
        # Add top 3 from each category
        for category, tickers in opportunities.items():
            for ticker in tickers[:3]:
                new_tickers.add(ticker['symbol'])
                
        self.dynamic_watchlist = list(new_tickers)
        logger.info(f"Watchlist updated: {self.dynamic_watchlist}")
        
    def get_full_watchlist(self) -> List[str]:
        return self.base_watchlist + self.dynamic_watchlist
```

**Step 3: Morning Report Integration (1.5 hours)**

```python
# Add to UnifiedAlphaMonitor

def _run_morning_scan(self):
    """Run at 9:35 AM ET."""
    opportunities = self.scanner.get_daily_opportunities()
    self.watchlist_manager.update_from_scanner(opportunities)
    
    # Send morning report
    embed = {
        "title": "üîç MORNING OPPORTUNITY SCAN",
        "fields": [
            {"name": "ü©≥ High Short Interest", "value": self._format_tickers(opportunities['high_short_interest'][:5])},
            {"name": "üìà Unusual Volume", "value": self._format_tickers(opportunities['unusual_volume'][:5])},
            {"name": "üìÖ Near Earnings", "value": self._format_tickers(opportunities['near_earnings'][:5])}
        ]
    }
    self.send_discord(embed, alert_type="morning_scan")
```

### Success Criteria

| Metric | Target | Validation Method |
|--------|--------|-------------------|
| New Opportunities Found | 5-15/day | Log scanner results |
| Scanner ‚Üí Signal Conversion | >10% | Track which scanned tickers generate signals |
| Signal Win Rate from Scanner | >50% | Separate tracking for scanner-sourced signals |

---

## PHASE 4: FTD EXPLOITATION (T+35 FORCED BUYING) üìà

### Why This Fourth?

- **Predictable timing:** FTDs must be covered by T+35
- **Simple logic:** Just track FTD spikes and settlement dates
- **Low effort:** Single API endpoint

### Data Source

| Endpoint | Data | Current Status |
|----------|------|----------------|
| `/data/stocks/failure-to-deliver/` | FTD records | ‚ùå Not used |

### Integration Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 FTD ANALYZER MODULE                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                ‚îÇ
‚îÇ  RUN FREQUENCY: Daily at market open                          ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  STEP 1: Fetch FTD Data                                       ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ GET /data/stocks/failure-to-deliver/?symbol=US:{ticker}  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Get last 45 days of FTD records                         ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  STEP 2: Calculate FTD Metrics                                ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ total_ftd = sum of FTD shares                           ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ avg_ftd = average daily FTD                             ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ spike_days = days where FTD > 3x avg                    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ settlement_dates = spike_days + 35                      ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  STEP 3: Generate Alert for Upcoming Settlements              ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ IF settlement_date within 5 days                        ‚îÇ
‚îÇ  ‚îÇ   AND ftd_spike_size > 500K shares                        ‚îÇ
‚îÇ  ‚îÇ   ‚Üí ALERT: Forced buying expected                         ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Include: expected shares, settlement date, impact %     ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  OUTPUT: FTDAlert ‚Üí AlertManager                              ‚îÇ
‚îÇ                                                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### File Structure

```
live_monitoring/
‚îî‚îÄ‚îÄ exploitation/
    ‚îî‚îÄ‚îÄ ftd_analyzer.py           # FTD tracking + settlement alerts
```

### Implementation (3 hours total)

```python
# live_monitoring/exploitation/ftd_analyzer.py

@dataclass
class FTDAlert:
    symbol: str
    settlement_date: date
    ftd_shares: int
    ftd_pct_of_float: float
    days_until_settlement: int
    expected_buying_pressure: str  # LOW, MEDIUM, HIGH
    reasoning: str

class FTDAnalyzer:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.t_plus_35 = 35  # Settlement rule
        
    def analyze(self, symbol: str) -> List[FTDAlert]:
        """
        Analyze FTD data for upcoming forced buying events.
        """
        ftd_data = self._fetch_ftd_data(symbol, days=45)
        if not ftd_data:
            return []
            
        # Calculate average
        avg_ftd = sum(d['quantity'] for d in ftd_data) / len(ftd_data)
        
        # Find spike days
        alerts = []
        for record in ftd_data:
            if record['quantity'] > avg_ftd * 3 and record['quantity'] > 500000:
                # Calculate settlement date
                spike_date = datetime.strptime(record['date'], '%Y-%m-%d').date()
                settlement_date = spike_date + timedelta(days=self.t_plus_35)
                days_until = (settlement_date - date.today()).days
                
                if 0 < days_until <= 5:
                    # Alert! Settlement coming
                    alerts.append(FTDAlert(
                        symbol=symbol,
                        settlement_date=settlement_date,
                        ftd_shares=record['quantity'],
                        ftd_pct_of_float=self._calc_pct_of_float(symbol, record['quantity']),
                        days_until_settlement=days_until,
                        expected_buying_pressure=self._classify_pressure(record['quantity']),
                        reasoning=f"{record['quantity']:,} FTDs from {spike_date} settling on {settlement_date}"
                    ))
                    
        return alerts
```

### Success Criteria

| Metric | Target | Validation Method |
|--------|--------|-------------------|
| FTD Settlement Accuracy | 100% | Verify T+35 calculation |
| Price Impact Correlation | >50% | Track price action around settlement |
| Alert Timing | 3-5 days before | Verify alert lead time |

---

## PHASE 5: ENHANCED REDDIT SENTIMENT üß†

### Why This Fifth?

- **Contrarian edge:** Retail is usually wrong
- **Already partially built:** Reddit sentiment module exists
- **Easy enhancement:** Just add more endpoints

### Data Sources

| Endpoint | Data | Current Status |
|----------|------|----------------|
| `/data/reddit/mentions/top/` | Top mentioned tickers | ‚ö†Ô∏è Partial |
| `/data/reddit/mentions/stock/` | Per-ticker mentions | ‚ö†Ô∏è Partial |
| `/data/reddit/mentions/daily/stock/` | Daily trend | ‚ùå Not used |

### Enhancement Plan

```python
# Enhance existing live_monitoring/core/reddit_sentiment.py

class EnhancedRedditSentiment:
    def get_daily_trend(self, symbol: str, days: int = 7) -> Dict:
        """
        GET /data/reddit/mentions/daily/stock/
        
        Calculate:
        - mention_trend: UP, DOWN, FLAT
        - momentum: rate of change in mentions
        - peak_detection: did mentions just spike?
        """
        
    def get_sentiment_signal(self, symbol: str) -> Optional[SentimentSignal]:
        """
        Generate contrarian signal based on Reddit sentiment.
        
        Logic:
        - Mentions spiking 5x+ AND bullish sentiment > 80% ‚Üí FADE (SHORT)
        - Mentions dropping AND sentiment turning negative ‚Üí STEALTH ACCUMULATION (LONG)
        - Mentions stable ‚Üí NO SIGNAL
        """
```

---

## üìã IMPLEMENTATION ROADMAP

### Week 1: Foundation

| Day | Task | Hours | Deliverable |
|-----|------|-------|-------------|
| Mon | Short data fetcher | 2 | `short_data_fetcher.py` |
| Mon | Squeeze detector core | 3 | `squeeze_detector.py` |
| Tue | Squeeze tests | 2 | `test_squeeze_detector.py` |
| Tue | Squeeze integration | 2 | Updated `unified_monitor.py` |
| Wed | Options data fetcher | 1.5 | `options_data_fetcher.py` |
| Wed | Gamma tracker | 2.5 | `gamma_tracker.py` |
| Thu | Gamma tests | 1.5 | `test_gamma_tracker.py` |
| Thu | Gamma integration | 1 | Updated `regime_detector.py` |
| Fri | End-to-end testing | 3 | Integration tests pass |

### Week 2: Expansion

| Day | Task | Hours | Deliverable |
|-----|------|-------|-------------|
| Mon | Opportunity scanner | 2 | `opportunity_scanner.py` |
| Mon | Watchlist manager | 1.5 | `watchlist_manager.py` |
| Tue | Scanner integration | 1.5 | Morning scan in monitor |
| Tue | FTD analyzer | 3 | `ftd_analyzer.py` |
| Wed | FTD integration | 1 | FTD alerts working |
| Wed | Reddit enhancement | 2 | Enhanced sentiment |
| Thu | Full system testing | 3 | All modules tested |
| Fri | Production deployment | 2 | Live on Render |

---

## üß™ TESTING STRATEGY

### Unit Test Requirements

Every new module MUST have:
1. **Happy path test:** Normal data returns expected result
2. **API failure test:** Returns None/empty, doesn't crash
3. **Edge case test:** Boundary conditions handled
4. **Integration test:** Works with existing modules

### Validation Requirements

Before any module goes to production:
1. **Historical backtest:** Does it catch known events?
2. **Paper trading:** Does it work in real-time?
3. **A/B comparison:** Does it improve overall win rate?

### Production Monitoring

Every new signal type gets:
1. **Separate tracking:** Win rate, P&L per signal type
2. **Alert logging:** All alerts to database
3. **Weekly review:** Performance analysis

---

## üéØ SUCCESS METRICS

### Overall System Targets

| Metric | Current | Target | Timeline |
|--------|---------|--------|----------|
| Signal Types | 4 | 8+ | 2 weeks |
| Daily Opportunities | 5-10 | 15-25 | 2 weeks |
| Win Rate | ~55% | 60-65% | 4 weeks |
| Signals from New Sources | 0% | 30%+ | 4 weeks |
| Ticker Coverage | 2 | 10+ | 2 weeks |

### Per-Module Targets

| Module | Win Rate Target | Validation |
|--------|-----------------|------------|
| Squeeze Detector | 60%+ | Historical squeeze backtest |
| Gamma Tracker | 55%+ | Max pain correlation |
| Opportunity Scanner | 50%+ | Scanner-sourced signal tracking |
| FTD Analyzer | 55%+ | Settlement date price action |
| Reddit Sentiment | 55%+ | Contrarian fade tracking |

---

## ‚ö†Ô∏è RISK MITIGATION

### What Could Go Wrong

1. **API rate limits:** Tier 3 = 1000 req/min, we need to track usage
2. **Data quality:** Some endpoints may return stale/missing data
3. **Over-trading:** More signals ‚â† better, need quality filter
4. **Complexity creep:** Adding too many modules = harder to debug

### Mitigations

1. **Rate limit tracking:** Add request counter, throttle if needed
2. **Data validation:** Every fetcher checks data freshness
3. **Signal quality gate:** New signal types start with higher threshold
4. **Modular architecture:** Each module is independent, can disable

---

## üî• ALPHA'S FINAL WORD

This plan is **executable**, **testable**, and **connected** to our existing system. No theoretical bullshit, no orphan modules.

**Priority Order:**
1. Squeeze Detection (highest edge potential)
2. Gamma Tracking (clear mechanics)
3. Opportunity Scanner (expands scope)
4. FTD Analyzer (predictable timing)
5. Reddit Enhancement (easy win)

**Start Date:** Now  
**First Deliverable:** Squeeze detector working by end of Week 1

---

**"We don't build features. We build EDGE."** üöÄüí∞üî•
