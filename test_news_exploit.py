#!/usr/bin/env python3
"""
TEST NEWS EXPLOIT - Can we make money from narrative divergences?

The EDGE:
- Headlines say "panic/selloff" + Dark pools show accumulation ‚Üí BUY THE DIP
- Headlines say "rally/bullish" + Dark pools show distribution ‚Üí SELL THE RIP

This test:
1. Runs the narrative pipeline for recent dates
2. Detects divergences between news and institutional flow
3. Generates signals based on divergences
4. Validates if those signals would have been profitable
"""

import sys
import os
import json
import logging
from datetime import datetime, timedelta
from pathlib import Path

# Setup paths
sys.path.append(str(Path(__file__).parent))
sys.path.append(str(Path(__file__).parent / 'live_monitoring' / 'enrichment'))
sys.path.append(str(Path(__file__).parent / 'live_monitoring' / 'core'))
sys.path.append(str(Path(__file__).parent / 'core'))
sys.path.append(str(Path(__file__).parent / 'core' / 'data'))
sys.path.append(str(Path(__file__).parent / 'configs'))

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def test_institutional_narrative_only():
    """Test just the institutional narrative loader (no Perplexity needed)"""
    print("=" * 80)
    print("üß™ TEST 1: INSTITUTIONAL NARRATIVE (No API keys needed)")
    print("=" * 80)
    
    try:
        from live_monitoring.enrichment.institutional_narrative import (
            load_institutional_context,
            DivergenceDetector,
            InstitutionalNarrativeSynthesizer
        )
        
        symbol = "SPY"
        today = datetime.now().strftime("%Y-%m-%d")
        
        print(f"\nüìä Loading institutional context for {symbol} on {today}...")
        ctx = load_institutional_context(symbol, today)
        
        print(f"\n‚úÖ INSTITUTIONAL CONTEXT:")
        print(f"   Symbol: {ctx.get('symbol')}")
        print(f"   Date: {ctx.get('date')}")
        print(f"   Current Price: ${ctx.get('current_price', 0):.2f}")
        print(f"   Daily Change: {ctx.get('pct_change', 0):.2f}%")
        print(f"   Dark Pool %: {ctx.get('dark_pool', {}).get('pct', 'N/A')}")
        print(f"   Dark Pool Volume: {ctx.get('dark_pool', {}).get('volume', 'N/A')}")
        print(f"   Lit Exchange %: {ctx.get('lit_exchange', {}).get('pct', 'N/A')}")
        print(f"   Max Pain: ${ctx.get('max_pain', 'N/A')}")
        print(f"   Crypto Correlation: {ctx.get('crypto_correlation')}")
        
        # Test with simulated news narratives
        print("\nüîç TESTING DIVERGENCE DETECTION WITH SIMULATED NEWS...")
        
        test_cases = [
            {
                "name": "Bearish News + Bullish DP (BUY SIGNAL)",
                "news": "SPY crashed today amid panic selling and risk-off sentiment. Markets in turmoil.",
                "expected_signal": "BUY"
            },
            {
                "name": "Bullish News + Bearish DP (SELL SIGNAL)",
                "news": "SPY rallied strongly today on bullish AI optimism and risk-on sentiment. Markets surge higher.",
                "expected_signal": "SELL"
            },
            {
                "name": "Neutral News (NO SIGNAL)",
                "news": "SPY traded sideways today with normal volatility. Routine market activity.",
                "expected_signal": "NEUTRAL"
            }
        ]
        
        detector = DivergenceDetector()
        synthesizer = InstitutionalNarrativeSynthesizer()
        
        for case in test_cases:
            print(f"\n   üì∞ Test Case: {case['name']}")
            print(f"      News: {case['news'][:80]}...")
            
            divergences = detector.detect_manipulation(symbol, today, case['news'], ctx)
            narrative = synthesizer.generate_real_narrative(symbol, today, ctx, case['news'], divergences)
            
            print(f"      Divergences Found: {len(divergences)}")
            if divergences:
                for div in divergences:
                    print(f"         - Type: {div.get('type')}")
                    print(f"           Severity: {div.get('severity')}")
                    print(f"           Signal: {div.get('signal')}")
            else:
                print(f"         - No divergences detected")
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Test failed: {e}")
        import traceback
        traceback.print_exc()
        return False


def test_narrative_pipeline_with_perplexity():
    """Test full narrative pipeline (requires Perplexity API key)"""
    print("\n" + "=" * 80)
    print("üß™ TEST 2: FULL NARRATIVE PIPELINE (Requires PERPLEXITY_API_KEY)")
    print("=" * 80)
    
    # Check for API key
    perplexity_key = os.getenv("PERPLEXITY_API_KEY")
    if not perplexity_key:
        print("\n‚ö†Ô∏è  PERPLEXITY_API_KEY not set - skipping full pipeline test")
        print("   Set it with: export PERPLEXITY_API_KEY='pplx-xxx'")
        return None
    
    try:
        from live_monitoring.enrichment.market_narrative_pipeline import market_narrative_pipeline
        
        symbol = "SPY"
        today = datetime.now().strftime("%Y-%m-%d")
        
        print(f"\nüß† Running full narrative pipeline for {symbol} on {today}...")
        print("   (This fetches real-time news and compares with institutional data)")
        
        narrative = market_narrative_pipeline(symbol, today, enable_logging=True)
        
        print(f"\n‚úÖ NARRATIVE RESULT:")
        print(f"   Symbol: {narrative.symbol}")
        print(f"   Date: {narrative.date}")
        print(f"   Overall Direction: {narrative.overall_direction}")
        print(f"   Risk Environment: {narrative.risk_environment}")
        print(f"   Conviction: {narrative.conviction}")
        print(f"   Duration: {narrative.duration}")
        print(f"\n   Causal Chain: {narrative.causal_chain}")
        
        print(f"\n   üì∞ MACRO NARRATIVE (First 300 chars):")
        print(f"      {narrative.macro_narrative[:300]}...")
        
        if narrative.divergences:
            print(f"\n   üéØ DIVERGENCES DETECTED: {len(narrative.divergences)}")
            for div in narrative.divergences:
                print(f"      - Type: {div.get('type')}")
                print(f"        Signal: {div.get('signal')}")
                print(f"        Severity: {div.get('severity')}")
        else:
            print(f"\n   üìä No divergences detected (news aligns with institutional flow)")
        
        if narrative.uncertainties:
            print(f"\n   ‚ö†Ô∏è  UNCERTAINTIES:")
            for u in narrative.uncertainties[:3]:
                print(f"      - {u}")
        
        return narrative
        
    except Exception as e:
        logger.error(f"‚ùå Pipeline test failed: {e}")
        import traceback
        traceback.print_exc()
        return None


def test_divergence_profitability():
    """
    Test if divergence-based signals would have been profitable.
    
    Strategy:
    - When we detect DISTRIBUTION_MASKED_AS_RALLY ‚Üí SHORT
    - When we detect ACCUMULATION_MASKED_AS_PANIC ‚Üí LONG
    - Check next day's price action
    """
    print("\n" + "=" * 80)
    print("üß™ TEST 3: DIVERGENCE PROFITABILITY CHECK")
    print("=" * 80)
    
    try:
        import yfinance as yf
        from live_monitoring.enrichment.institutional_narrative import (
            load_institutional_context,
            DivergenceDetector
        )
        
        symbol = "SPY"
        
        # Get recent price history
        ticker = yf.Ticker(symbol)
        hist = ticker.history(period="10d", interval="1d")
        
        if hist.empty:
            print("‚ùå Could not fetch price history")
            return False
        
        print(f"\nüìä Recent {symbol} Price Action:")
        print(f"   Last 5 days:")
        for i in range(-5, 0):
            date = hist.index[i].strftime("%Y-%m-%d")
            close = hist['Close'].iloc[i]
            if i < -1:
                prev_close = hist['Close'].iloc[i-1]
                change = ((close / prev_close) - 1) * 100
            else:
                change = 0
            print(f"      {date}: ${close:.2f} ({change:+.2f}%)")
        
        print("\nüéØ DIVERGENCE-BASED SIGNAL STRATEGY:")
        print("   IF headlines say 'panic' BUT DP shows accumulation ‚Üí BUY")
        print("   IF headlines say 'rally' BUT DP shows distribution ‚Üí SELL")
        
        # Test today's institutional context
        today = datetime.now().strftime("%Y-%m-%d")
        yesterday = (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d")
        
        print(f"\nüìà Loading institutional context for {yesterday}...")
        ctx = load_institutional_context(symbol, yesterday)
        
        dp_pct = ctx.get('dark_pool', {}).get('pct')
        if dp_pct is not None:
            print(f"   Dark Pool %: {dp_pct:.2f}%")
            
            if dp_pct > 40:
                print(f"   üí∞ HIGH DP ACTIVITY (>40%) - Institutions are ACTIVE")
                print(f"   ‚Üí If news is bearish, this is a BUY signal (stealth accumulation)")
            elif dp_pct < 25:
                print(f"   ‚ö†Ô∏è  LOW DP ACTIVITY (<25%) - Institutions selling on LIT")
                print(f"   ‚Üí If news is bullish, this is a SELL signal (distribution)")
            else:
                print(f"   üìä NEUTRAL DP ACTIVITY (25-40%) - Mixed signals")
        else:
            print(f"   ‚ö†Ô∏è  No DP data available for yesterday")
        
        # Calculate what would have happened
        last_close = hist['Close'].iloc[-1]
        prev_close = hist['Close'].iloc[-2]
        today_change = ((last_close / prev_close) - 1) * 100
        
        print(f"\nüìä TODAY'S RESULT:")
        print(f"   Close: ${last_close:.2f}")
        print(f"   Change: {today_change:+.2f}%")
        
        # Determine if our signal would have worked
        if dp_pct is not None:
            if dp_pct > 40 and today_change > 0:
                print(f"\n   ‚úÖ BUY SIGNAL WOULD HAVE BEEN PROFITABLE!")
                print(f"      High DP (accumulation) + Price went UP = WIN")
            elif dp_pct < 25 and today_change < 0:
                print(f"\n   ‚úÖ SELL SIGNAL WOULD HAVE BEEN PROFITABLE!")
                print(f"      Low DP (distribution) + Price went DOWN = WIN")
            else:
                print(f"\n   ‚ö†Ô∏è  Signal vs price action mismatch - needs more context")
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Profitability test failed: {e}")
        import traceback
        traceback.print_exc()
        return False


def generate_news_exploit_signal():
    """Generate an actionable signal based on news vs institutional divergence"""
    print("\n" + "=" * 80)
    print("üé∞ GENERATING NEWS EXPLOIT SIGNAL")
    print("=" * 80)
    
    try:
        import yfinance as yf
        from live_monitoring.enrichment.institutional_narrative import (
            load_institutional_context,
            DivergenceDetector
        )
        
        symbol = "SPY"
        today = datetime.now().strftime("%Y-%m-%d")
        
        # Get institutional context
        print(f"\nüìä Loading institutional context for {symbol}...")
        ctx = load_institutional_context(symbol, today)
        
        current_price = ctx.get('current_price', 0)
        daily_change = ctx.get('pct_change', 0)
        dp_pct = ctx.get('dark_pool', {}).get('pct')
        dp_volume = ctx.get('dark_pool', {}).get('volume', 0)
        crypto_corr = ctx.get('crypto_correlation')
        
        print(f"\nüìà CURRENT STATE:")
        print(f"   Price: ${current_price:.2f}")
        print(f"   Daily Change: {daily_change:+.2f}%")
        print(f"   Dark Pool %: {dp_pct:.2f}%" if dp_pct else "   Dark Pool %: N/A")
        print(f"   Dark Pool Volume: {dp_volume:,}" if dp_volume else "   Dark Pool Volume: N/A")
        print(f"   Crypto Correlation: {crypto_corr}")
        
        # Determine signal based on divergence logic
        signal = "HOLD"
        confidence = 0.0
        reasoning = []
        
        if dp_pct is not None and current_price > 0:
            # CASE 1: Price down but high DP activity = ACCUMULATION ‚Üí BUY
            if daily_change < -0.5 and dp_pct > 40:
                signal = "BUY"
                confidence = 0.70
                reasoning.append(f"Price DOWN {daily_change:.2f}% but HIGH DP activity ({dp_pct:.1f}%)")
                reasoning.append("Institutions accumulating while retail panics")
                reasoning.append("‚Üí Classic 'buy the dip' setup")
            
            # CASE 2: Price up but low DP activity = DISTRIBUTION ‚Üí SELL
            elif daily_change > 0.5 and dp_pct < 25:
                signal = "SELL"
                confidence = 0.70
                reasoning.append(f"Price UP {daily_change:.2f}% but LOW DP activity ({dp_pct:.1f}%)")
                reasoning.append("Institutions distributing while retail FOMO")
                reasoning.append("‚Üí Classic 'sell the rip' setup")
            
            # CASE 3: High DP with price flat = ACCUMULATION starting
            elif abs(daily_change) < 0.3 and dp_pct > 50:
                signal = "BUY"
                confidence = 0.60
                reasoning.append(f"Price FLAT but VERY HIGH DP activity ({dp_pct:.1f}%)")
                reasoning.append("Stealth accumulation in progress")
                reasoning.append("‚Üí Bullish breakout likely")
            
            # CASE 4: Low DP with price flat = DISTRIBUTION ending
            elif abs(daily_change) < 0.3 and dp_pct < 20:
                signal = "SELL"
                confidence = 0.60
                reasoning.append(f"Price FLAT but VERY LOW DP activity ({dp_pct:.1f}%)")
                reasoning.append("Institutions have distributed")
                reasoning.append("‚Üí Bearish breakdown likely")
            
            else:
                signal = "HOLD"
                confidence = 0.50
                reasoning.append("No clear divergence detected")
                reasoning.append(f"DP % ({dp_pct:.1f}%) and price change ({daily_change:+.2f}%) are aligned")
        
        # Crypto confirmation
        if crypto_corr == "SIMULTANEOUS_DROP" and signal == "BUY":
            confidence -= 0.10
            reasoning.append("‚ö†Ô∏è  Crypto also dropping - reduce confidence")
        elif crypto_corr == "DIVERGENCE" and signal == "BUY":
            confidence += 0.05
            reasoning.append("‚úÖ Crypto diverging positively - add confidence")
        
        # Generate trade parameters
        stop_loss = current_price * 0.98 if signal == "BUY" else current_price * 1.02
        target = current_price * 1.02 if signal == "BUY" else current_price * 0.98
        
        print(f"\nüéØ NEWS EXPLOIT SIGNAL:")
        print(f"   {'='*50}")
        print(f"   Signal: {signal}")
        print(f"   Confidence: {confidence:.0%}")
        print(f"   {'='*50}")
        if signal != "HOLD":
            print(f"   Entry: ${current_price:.2f}")
            print(f"   Stop Loss: ${stop_loss:.2f}")
            print(f"   Target: ${target:.2f}")
            print(f"   Risk/Reward: 1:1")
        print(f"\n   üìù REASONING:")
        for r in reasoning:
            print(f"      - {r}")
        
        return {
            "symbol": symbol,
            "signal": signal,
            "confidence": confidence,
            "entry": current_price,
            "stop_loss": stop_loss,
            "target": target,
            "reasoning": reasoning
        }
        
    except Exception as e:
        logger.error(f"‚ùå Signal generation failed: {e}")
        import traceback
        traceback.print_exc()
        return None


def main():
    """Run all tests"""
    print("=" * 80)
    print("üî• NEWS EXPLOIT TEST SUITE")
    print("   Testing if we can make money from narrative divergences")
    print("=" * 80)
    
    # Test 1: Institutional narrative (no API keys needed)
    test1_result = test_institutional_narrative_only()
    
    # Test 2: Full pipeline (requires Perplexity)
    test2_result = test_narrative_pipeline_with_perplexity()
    
    # Test 3: Profitability check
    test3_result = test_divergence_profitability()
    
    # Generate signal
    signal = generate_news_exploit_signal()
    
    # Summary
    print("\n" + "=" * 80)
    print("üìä TEST SUMMARY")
    print("=" * 80)
    print(f"   Test 1 (Institutional Narrative): {'‚úÖ PASS' if test1_result else '‚ùå FAIL'}")
    print(f"   Test 2 (Full Pipeline): {'‚úÖ PASS' if test2_result else '‚ö†Ô∏è  SKIPPED (no API key)' if test2_result is None else '‚ùå FAIL'}")
    print(f"   Test 3 (Profitability Check): {'‚úÖ PASS' if test3_result else '‚ùå FAIL'}")
    
    if signal:
        print(f"\n   üé∞ GENERATED SIGNAL: {signal['signal']} @ {signal['confidence']:.0%} confidence")
    
    print("\n" + "=" * 80)
    print("üí° NEXT STEPS TO EXPLOIT NEWS:")
    print("=" * 80)
    print("   1. Set PERPLEXITY_API_KEY for real-time news fetching")
    print("   2. Run full pipeline during market hours")
    print("   3. Monitor divergences between news and DP flow")
    print("   4. When divergence detected ‚Üí Generate signal")
    print("   5. Paper trade first, then small live positions")


if __name__ == "__main__":
    main()

