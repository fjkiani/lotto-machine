#!/usr/bin/env python3
"""
ðŸ”¥ NEWS EXPLOIT PRODUCTION MONITOR

This is the PRODUCTION version that:
1. Runs continuously during market hours
2. Updates news narrative every 15 minutes (Perplexity)
3. Checks dark pool data every 5 minutes (ChartExchange)
4. Detects institutional bias CHANGES
5. Sends Discord alerts when divergences detected
6. Logs everything for audit

TRIGGERS:
- Institutional bias CHANGE (NEUTRAL â†’ ACCUMULATING or DISTRIBUTING)
- Divergence detected (news vs institutional flow)
- Significant DP % change (>5% swing)
- News sentiment flip (BULLISH â†’ BEARISH or vice versa)

RUN FREQUENCY:
- News update: Every 15 minutes (Perplexity rate limits)
- DP check: Every 5 minutes
- Divergence check: Every 5 minutes
- Discord alerts: On trigger events only
"""

import os
import sys
import json
import time
import logging
import traceback
from datetime import datetime, timedelta
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import Optional, Dict, List

# Setup paths
sys.path.append(str(Path(__file__).parent))
sys.path.append(str(Path(__file__).parent / 'live_monitoring' / 'enrichment' / 'apis'))
sys.path.append(str(Path(__file__).parent / 'live_monitoring' / 'alerting'))
sys.path.append(str(Path(__file__).parent / 'configs'))
sys.path.append(str(Path(__file__).parent / 'core' / 'data'))

# Setup logging
log_dir = Path("logs/news_exploit")
log_dir.mkdir(parents=True, exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_dir / f"news_monitor_{datetime.now().strftime('%Y%m%d')}.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


# ============================================================
# DATA MODELS
# ============================================================

@dataclass
class NewsState:
    """Current news state"""
    timestamp: str
    sentiment: str  # BULLISH, BEARISH, NEUTRAL
    confidence: float
    main_narrative: str
    key_drivers: List[str]
    bullish_signals: int
    bearish_signals: int


@dataclass 
class InstitutionalState:
    """Current institutional flow state"""
    timestamp: str
    symbol: str
    price: float
    dp_pct: float
    dp_volume: int
    total_volume: int
    bias: str  # ACCUMULATING, DISTRIBUTING, NEUTRAL
    battlegrounds: List[float]


@dataclass
class DivergenceAlert:
    """Alert when divergence detected"""
    timestamp: str
    symbol: str
    alert_type: str  # DIVERGENCE, BIAS_CHANGE, SENTIMENT_FLIP
    news_sentiment: str
    institutional_bias: str
    dp_pct: float
    signal: str  # BUY, SELL, HOLD
    confidence: float
    entry_price: float
    stop_loss: float
    target: float
    reasoning: List[str]


# ============================================================
# ENV LOADER
# ============================================================

def load_env():
    """Load environment variables from .env file"""
    try:
        with open('.env', 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    os.environ[key.strip()] = value.strip().strip('"').strip("'")
    except Exception as e:
        logger.warning(f"Could not load .env: {e}")


# ============================================================
# NEWS FETCHER (Perplexity)
# ============================================================

class NewsMonitor:
    """Monitors news using Perplexity AI"""
    
    def __init__(self):
        load_env()
        self.api_key = os.getenv('PERPLEXITY_API_KEY')
        self.last_state: Optional[NewsState] = None
        self.last_update: Optional[datetime] = None
        self.update_interval = 900  # 15 minutes in seconds
        
        if not self.api_key:
            logger.error("PERPLEXITY_API_KEY not set!")
    
    def should_update(self) -> bool:
        """Check if we should fetch new news"""
        if not self.last_update:
            return True
        elapsed = (datetime.now() - self.last_update).total_seconds()
        return elapsed >= self.update_interval
    
    def fetch_narrative(self) -> Optional[NewsState]:
        """Fetch current market narrative from Perplexity"""
        if not self.api_key:
            return None
        
        import requests
        
        query = """What is driving SPY and the US stock market right now? 
        Summarize the key catalysts, sentiment (bullish/bearish/neutral), 
        and main drivers in 2-3 sentences. Be specific and current."""
        
        try:
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json",
            }
            
            payload = {
                "model": "sonar",
                "messages": [{"role": "user", "content": query}],
                "search_recency_filter": "day",
                "return_citations": True,
            }
            
            resp = requests.post(
                "https://api.perplexity.ai/chat/completions",
                headers=headers,
                json=payload,
                timeout=30,
            )
            
            if resp.status_code != 200:
                logger.error(f"Perplexity API error: {resp.status_code}")
                return self.last_state
            
            data = resp.json()
            answer = data.get("choices", [{}])[0].get("message", {}).get("content", "")
            
            # Parse sentiment
            text_lower = answer.lower()
            bullish_words = ["rally", "surge", "gain", "bullish", "optimism", "record", "rise", "higher", "positive", "strong"]
            bearish_words = ["selloff", "crash", "drop", "bearish", "fear", "decline", "down", "lower", "negative", "concern", "weak"]
            
            bullish_count = sum(1 for w in bullish_words if w in text_lower)
            bearish_count = sum(1 for w in bearish_words if w in text_lower)
            
            if bullish_count > bearish_count + 2:
                sentiment = "BULLISH"
                confidence = min((bullish_count - bearish_count) / 10, 1.0)
            elif bearish_count > bullish_count + 2:
                sentiment = "BEARISH"
                confidence = min((bearish_count - bullish_count) / 10, 1.0)
            else:
                sentiment = "NEUTRAL"
                confidence = 0.5
            
            state = NewsState(
                timestamp=datetime.now().isoformat(),
                sentiment=sentiment,
                confidence=confidence,
                main_narrative=answer[:500],
                key_drivers=[],  # Could parse this later
                bullish_signals=bullish_count,
                bearish_signals=bearish_count
            )
            
            self.last_state = state
            self.last_update = datetime.now()
            
            return state
            
        except Exception as e:
            logger.error(f"Error fetching news: {e}")
            return self.last_state
    
    def get_current_state(self) -> Optional[NewsState]:
        """Get current news state, fetching if needed"""
        if self.should_update():
            logger.info("ðŸ“° Fetching fresh news from Perplexity...")
            return self.fetch_narrative()
        return self.last_state


# ============================================================
# INSTITUTIONAL FLOW MONITOR (ChartExchange)
# ============================================================

class InstitutionalMonitor:
    """Monitors institutional flow via dark pools"""
    
    def __init__(self, symbols: List[str] = ["SPY", "QQQ"]):
        load_env()
        self.symbols = symbols
        self.api_key = None
        self.client = None
        self.last_states: Dict[str, InstitutionalState] = {}
        self.last_update: Optional[datetime] = None
        self.update_interval = 300  # 5 minutes
        
        # Initialize ChartExchange client
        try:
            from chartexchange_config import get_api_key
            from ultimate_chartexchange_client import UltimateChartExchangeClient
            
            self.api_key = get_api_key()
            self.client = UltimateChartExchangeClient(api_key=self.api_key, tier=3)
            logger.info("âœ… ChartExchange client initialized")
        except Exception as e:
            logger.error(f"Failed to initialize ChartExchange: {e}")
    
    def should_update(self) -> bool:
        """Check if we should fetch new DP data"""
        if not self.last_update:
            return True
        elapsed = (datetime.now() - self.last_update).total_seconds()
        return elapsed >= self.update_interval
    
    def fetch_institutional_data(self, symbol: str) -> Optional[InstitutionalState]:
        """Fetch current institutional flow for a symbol"""
        if not self.client:
            return None
        
        import yfinance as yf
        
        try:
            # Get price data
            ticker = yf.Ticker(symbol)
            hist = ticker.history(period="2d", interval="1d")
            
            if hist.empty:
                return self.last_states.get(symbol)
            
            price = float(hist['Close'].iloc[-1])
            total_vol = int(hist['Volume'].iloc[-1])
            
            # Get DP data (use yesterday for complete data)
            yesterday = (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d")
            while datetime.strptime(yesterday, "%Y-%m-%d").weekday() >= 5:
                yesterday = (datetime.strptime(yesterday, "%Y-%m-%d") - timedelta(days=1)).strftime("%Y-%m-%d")
            
            dp_levels = self.client.get_dark_pool_levels(symbol, yesterday)
            
            dp_vol = 0
            battlegrounds = []
            if dp_levels:
                for level in dp_levels:
                    if isinstance(level, dict):
                        if 'volume' in level:
                            dp_vol += int(level['volume'])
                        if 'level' in level:
                            battlegrounds.append(float(level['level']))
            
            dp_pct = (dp_vol / total_vol * 100) if total_vol > 0 else 0
            
            # Determine bias
            if dp_pct > 45:
                bias = "ACCUMULATING"
            elif dp_pct < 25:
                bias = "DISTRIBUTING"
            else:
                bias = "NEUTRAL"
            
            state = InstitutionalState(
                timestamp=datetime.now().isoformat(),
                symbol=symbol,
                price=price,
                dp_pct=dp_pct,
                dp_volume=dp_vol,
                total_volume=total_vol,
                bias=bias,
                battlegrounds=sorted(battlegrounds, reverse=True)[:5]  # Top 5 levels
            )
            
            self.last_states[symbol] = state
            return state
            
        except Exception as e:
            logger.error(f"Error fetching institutional data for {symbol}: {e}")
            return self.last_states.get(symbol)
    
    def get_current_state(self, symbol: str) -> Optional[InstitutionalState]:
        """Get current institutional state for a symbol"""
        if self.should_update():
            logger.info(f"ðŸ¦ Fetching institutional flow for {symbol}...")
            state = self.fetch_institutional_data(symbol)
            self.last_update = datetime.now()
            return state
        return self.last_states.get(symbol)
    
    def detect_bias_change(self, symbol: str, new_state: InstitutionalState) -> Optional[str]:
        """Detect if institutional bias changed"""
        old_state = self.last_states.get(symbol)
        if not old_state:
            return None
        
        if old_state.bias != new_state.bias:
            return f"{old_state.bias} â†’ {new_state.bias}"
        return None


# ============================================================
# DIVERGENCE DETECTOR
# ============================================================

class DivergenceDetector:
    """Detects divergences between news and institutional flow"""
    
    def __init__(self):
        self.last_alert: Optional[DivergenceAlert] = None
        self.alert_cooldown = 1800  # 30 minutes between same alerts
        self.last_alert_time: Optional[datetime] = None
    
    def check_divergence(
        self, 
        news: NewsState, 
        institutional: InstitutionalState
    ) -> Optional[DivergenceAlert]:
        """Check for divergence between news and institutional flow"""
        
        alert_type = None
        signal = "HOLD"
        confidence = 0.40
        reasoning = []
        
        news_sent = news.sentiment
        inst_bias = institutional.bias
        dp_pct = institutional.dp_pct
        price = institutional.price
        
        # =====================================================
        # DIVERGENCE RULES
        # =====================================================
        
        # CASE 1: News BEARISH + Institutions ACCUMULATING = BUY
        if news_sent == "BEARISH" and inst_bias == "ACCUMULATING":
            alert_type = "DIVERGENCE"
            signal = "BUY"
            confidence = 0.75 + (news.confidence * 0.15)
            reasoning.append(f"ðŸ”¥ DIVERGENCE: News is BEARISH but institutions are ACCUMULATING")
            reasoning.append(f"   Dark Pool: {dp_pct:.1f}% (>45% = heavy accumulation)")
            reasoning.append(f"   â†’ Institutions buying while retail panics")
        
        # CASE 2: News BULLISH + Institutions DISTRIBUTING = SELL
        elif news_sent == "BULLISH" and inst_bias == "DISTRIBUTING":
            alert_type = "DIVERGENCE"
            signal = "SELL"
            confidence = 0.75 + (news.confidence * 0.15)
            reasoning.append(f"ðŸ”¥ DIVERGENCE: News is BULLISH but institutions are DISTRIBUTING")
            reasoning.append(f"   Dark Pool: {dp_pct:.1f}% (<25% = heavy distribution)")
            reasoning.append(f"   â†’ Institutions selling while retail FOMOs")
        
        # CASE 3: Stealth accumulation
        elif news_sent == "NEUTRAL" and inst_bias == "ACCUMULATING":
            alert_type = "STEALTH"
            signal = "BUY"
            confidence = 0.65
            reasoning.append(f"ðŸ‘€ STEALTH ACCUMULATION: Quiet news but DP shows loading")
            reasoning.append(f"   Dark Pool: {dp_pct:.1f}% (high)")
        
        # CASE 4: Stealth distribution
        elif news_sent == "NEUTRAL" and inst_bias == "DISTRIBUTING":
            alert_type = "STEALTH"
            signal = "SELL"
            confidence = 0.65
            reasoning.append(f"ðŸ‘€ STEALTH DISTRIBUTION: Quiet news but DP shows unloading")
            reasoning.append(f"   Dark Pool: {dp_pct:.1f}% (low)")
        
        if not alert_type:
            return None
        
        # Check cooldown
        if self.last_alert_time:
            elapsed = (datetime.now() - self.last_alert_time).total_seconds()
            if elapsed < self.alert_cooldown:
                return None
        
        # Calculate trade levels
        if signal == "BUY":
            stop = price * 0.98
            target = price * 1.02
        else:
            stop = price * 1.02
            target = price * 0.98
        
        alert = DivergenceAlert(
            timestamp=datetime.now().isoformat(),
            symbol=institutional.symbol,
            alert_type=alert_type,
            news_sentiment=news_sent,
            institutional_bias=inst_bias,
            dp_pct=dp_pct,
            signal=signal,
            confidence=confidence,
            entry_price=price,
            stop_loss=stop,
            target=target,
            reasoning=reasoning
        )
        
        self.last_alert = alert
        self.last_alert_time = datetime.now()
        
        return alert


# ============================================================
# DISCORD ALERTER
# ============================================================

class NewsExploitDiscordAlerter:
    """Sends news exploit alerts to Discord"""
    
    def __init__(self):
        load_env()
        self.webhook_url = os.getenv('DISCORD_WEBHOOK_URL')
        
        if not self.webhook_url:
            logger.warning("âš ï¸ DISCORD_WEBHOOK_URL not set - Discord alerts disabled")
    
    def send_divergence_alert(self, alert: DivergenceAlert):
        """Send divergence alert to Discord"""
        if not self.webhook_url:
            return
        
        import requests
        
        # Color based on signal
        color = 65280 if alert.signal == "BUY" else 16711680  # Green for BUY, Red for SELL
        
        embed = {
            "title": f"ðŸ”¥ {alert.alert_type} DETECTED: {alert.symbol}",
            "description": "\n".join(alert.reasoning),
            "color": color,
            "fields": [
                {"name": "Signal", "value": f"**{alert.signal}**", "inline": True},
                {"name": "Confidence", "value": f"{alert.confidence:.0%}", "inline": True},
                {"name": "News Sentiment", "value": alert.news_sentiment, "inline": True},
                {"name": "Institutional Bias", "value": alert.institutional_bias, "inline": True},
                {"name": "Dark Pool %", "value": f"{alert.dp_pct:.1f}%", "inline": True},
                {"name": "Entry", "value": f"${alert.entry_price:.2f}", "inline": True},
                {"name": "Stop Loss", "value": f"${alert.stop_loss:.2f}", "inline": True},
                {"name": "Target", "value": f"${alert.target:.2f}", "inline": True},
            ],
            "footer": {"text": "News Exploit Monitor | Alpha Intelligence"},
            "timestamp": datetime.now().isoformat()
        }
        
        payload = {
            "username": "News Exploit Bot ðŸ”¥",
            "embeds": [embed]
        }
        
        try:
            requests.post(self.webhook_url, json=payload, timeout=5)
            logger.info(f"ðŸ“¢ Discord alert sent: {alert.alert_type} - {alert.signal}")
        except Exception as e:
            logger.error(f"Failed to send Discord alert: {e}")
    
    def send_status_update(self, news: NewsState, institutional: InstitutionalState):
        """Send periodic status update to Discord"""
        if not self.webhook_url:
            return
        
        import requests
        
        embed = {
            "title": "ðŸ“Š News Exploit Status Update",
            "color": 3447003,  # Blue
            "fields": [
                {"name": "News Sentiment", "value": f"{news.sentiment} ({news.confidence:.0%})", "inline": True},
                {"name": "Institutional Bias", "value": institutional.bias, "inline": True},
                {"name": f"{institutional.symbol} Price", "value": f"${institutional.price:.2f}", "inline": True},
                {"name": "Dark Pool %", "value": f"{institutional.dp_pct:.1f}%", "inline": True},
                {"name": "DP Volume", "value": f"{institutional.dp_volume:,}", "inline": True},
                {"name": "Divergence", "value": "NO" if news.sentiment != "BEARISH" or institutional.bias != "ACCUMULATING" else "YES", "inline": True},
            ],
            "footer": {"text": f"Last update: {news.timestamp[:19]}"},
        }
        
        payload = {
            "username": "News Exploit Bot ðŸ“Š",
            "embeds": [embed]
        }
        
        try:
            requests.post(self.webhook_url, json=payload, timeout=5)
        except Exception as e:
            logger.error(f"Failed to send status update: {e}")


# ============================================================
# MAIN MONITOR
# ============================================================

class NewsExploitMonitor:
    """Main orchestrator for news exploit monitoring"""
    
    def __init__(self, symbols: List[str] = ["SPY", "QQQ"]):
        self.symbols = symbols
        self.news_monitor = NewsMonitor()
        self.institutional_monitor = InstitutionalMonitor(symbols)
        self.divergence_detector = DivergenceDetector()
        self.discord = NewsExploitDiscordAlerter()
        
        # Tracking
        self.last_news_sentiment: Optional[str] = None
        self.last_institutional_bias: Dict[str, str] = {}
        self.check_count = 0
        self.status_update_interval = 12  # Send status every 12 checks (~1 hour)
    
    def is_market_hours(self) -> bool:
        """Check if market is open (extended hours included for news)"""
        now = datetime.now()
        hour = now.hour
        weekday = now.weekday()
        
        # Skip weekends
        if weekday >= 5:
            return False
        
        # Extended hours: 6am - 8pm ET for news monitoring
        return 6 <= hour < 20
    
    def run_check(self):
        """Run a single check cycle"""
        self.check_count += 1
        
        # Get news state
        news = self.news_monitor.get_current_state()
        if not news:
            logger.warning("Could not get news state")
            return
        
        # Check for news sentiment change
        if self.last_news_sentiment and news.sentiment != self.last_news_sentiment:
            logger.info(f"ðŸ“° NEWS SENTIMENT CHANGED: {self.last_news_sentiment} â†’ {news.sentiment}")
        self.last_news_sentiment = news.sentiment
        
        # Check each symbol
        for symbol in self.symbols:
            institutional = self.institutional_monitor.get_current_state(symbol)
            if not institutional:
                continue
            
            # Check for bias change
            old_bias = self.last_institutional_bias.get(symbol)
            if old_bias and institutional.bias != old_bias:
                logger.info(f"ðŸ¦ INSTITUTIONAL BIAS CHANGED for {symbol}: {old_bias} â†’ {institutional.bias}")
            self.last_institutional_bias[symbol] = institutional.bias
            
            # Check for divergence
            alert = self.divergence_detector.check_divergence(news, institutional)
            if alert:
                logger.info(f"ðŸ”¥ DIVERGENCE ALERT: {alert.signal} {symbol}")
                self.discord.send_divergence_alert(alert)
                
                # Log to file
                self._log_alert(alert)
            
            # Periodic status update
            if self.check_count % self.status_update_interval == 0:
                self.discord.send_status_update(news, institutional)
        
        # Console output
        self._print_status(news)
    
    def _print_status(self, news: NewsState):
        """Print current status to console"""
        print(f"\n{'='*60}")
        print(f"ðŸ“Š NEWS EXPLOIT MONITOR - {datetime.now().strftime('%H:%M:%S')}")
        print(f"{'='*60}")
        print(f"   News: {news.sentiment} ({news.confidence:.0%} confidence)")
        
        for symbol in self.symbols:
            inst = self.last_institutional_bias.get(symbol)
            state = self.institutional_monitor.last_states.get(symbol)
            if state:
                print(f"   {symbol}: {inst} (DP: {state.dp_pct:.1f}%, ${state.price:.2f})")
        
        print(f"   Checks: {self.check_count} | Next news update: {self.news_monitor.update_interval - (datetime.now() - self.news_monitor.last_update).total_seconds():.0f}s" if self.news_monitor.last_update else "")
    
    def _log_alert(self, alert: DivergenceAlert):
        """Log alert to file"""
        alert_file = log_dir / f"alerts_{datetime.now().strftime('%Y%m%d')}.json"
        
        alerts = []
        if alert_file.exists():
            with open(alert_file, 'r') as f:
                alerts = json.load(f)
        
        alerts.append(asdict(alert))
        
        with open(alert_file, 'w') as f:
            json.dump(alerts, f, indent=2)
    
    def run(self):
        """Main monitoring loop"""
        logger.info("ðŸš€ NEWS EXPLOIT MONITOR STARTING")
        logger.info(f"   Symbols: {', '.join(self.symbols)}")
        logger.info(f"   News update interval: {self.news_monitor.update_interval}s")
        logger.info(f"   DP check interval: {self.institutional_monitor.update_interval}s")
        logger.info(f"   Discord: {'âœ… Configured' if self.discord.webhook_url else 'âŒ Not configured'}")
        
        check_interval = 300  # Check every 5 minutes
        
        while True:
            try:
                if not self.is_market_hours():
                    logger.info("ðŸ˜´ Outside market hours. Sleeping...")
                    time.sleep(1800)  # Sleep 30 minutes
                    continue
                
                self.run_check()
                time.sleep(check_interval)
                
            except KeyboardInterrupt:
                logger.info("âš ï¸ Shutting down...")
                break
            except Exception as e:
                logger.error(f"Error in main loop: {e}")
                traceback.print_exc()
                time.sleep(60)


# ============================================================
# ENTRY POINT
# ============================================================

def main():
    """Run the news exploit monitor"""
    monitor = NewsExploitMonitor(symbols=["SPY", "QQQ"])
    monitor.run()


if __name__ == "__main__":
    main()

