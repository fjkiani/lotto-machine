#!/usr/bin/env python3
"""
Trading Economics Exploitation Engine
=====================================

Transform economic calendar data into actionable trading opportunities.
"""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class EconomicEvent:
    """Structured economic event data"""
    country: str
    event: str
    time: str
    date: str
    importance: int
    actual: Optional[str] = None
    forecast: Optional[str] = None
    previous: Optional[str] = None

    @property
    def event_datetime(self) -> datetime:
        """Parse event datetime"""
        try:
            # Handle different time formats
            if self.time and ':' in self.time:
                time_str = f"{self.date} {self.time}"
                return datetime.strptime(time_str, "%Y-%m-%d %H:%M")
            else:
                # Default to date only
                return datetime.strptime(self.date, "%Y-%m-%d")
        except:
            return datetime.now()

    @property
    def is_high_impact(self) -> bool:
        """Check if event is high impact"""
        return self.importance >= 3

    @property
    def has_data(self) -> bool:
        """Check if event has actual/forecast data"""
        return bool(self.actual or self.forecast or self.previous)


class EconomicCalendarExploiter:
    """
    Exploit economic calendar data for trading opportunities.

    This class transforms raw economic events into:
    - Volatility trading signals
    - Risk management zones
    - Economic surprise opportunities
    """

    def __init__(self):
        # Will integrate with MCP server later
        # For now, use mock data based on our analysis
        self.high_impact_events = [
            EconomicEvent(
                country="United States",
                event="Fed Interest Rate Decision",
                time="07:00 PM",
                date="2025-12-10",
                importance=3,
                forecast="3.75%",
                previous="4.0%"
            ),
            EconomicEvent(
                country="United States",
                event="Non Farm Payrolls",
                time="01:30 PM",
                date="2025-12-10",
                importance=3,
                previous="119K"
            ),
            EconomicEvent(
                country="European Union",
                event="ECB Interest Rate Decision",
                time="01:15 PM",
                date="2025-12-10",
                importance=3,
                previous="2.15%"
            ),
            EconomicEvent(
                country="United States",
                event="FOMC Economic Projections",
                time="07:00 PM",
                date="2025-12-10",
                importance=3
            ),
            EconomicEvent(
                country="China",
                event="Inflation Rate YoY",
                time="01:30 AM",
                date="2025-12-10",
                importance=2,
                forecast="0.7%",
                previous="0.2%"
            )
        ]

    async def get_volatility_opportunities(self, hours_ahead: int = 24) -> List[Dict[str, Any]]:
        """
        Identify volatility trading opportunities around economic events.

        Returns trading opportunities for volatility products (VIX, options, etc.)
        """
        opportunities = []
        now = datetime.now()

        for event in self.high_impact_events:
            event_time = event.event_datetime
            time_until = (event_time - now).total_seconds() / 3600

            if 0 < time_until <= hours_ahead:
                # Pre-event opportunity
                opportunities.append({
                    'type': 'volatility_pre_event',
                    'event': event,
                    'time_until_hours': round(time_until, 1),
                    'action': 'BUY_VOLATILITY',
                    'instruments': ['VIX', 'SPY_PUTS', 'QQQ_OPTIONS'],
                    'rationale': f"High-impact {event.event} approaching - volatility spike expected",
                    'confidence': self._calculate_confidence(event),
                    'entry_window': {
                        'start': event_time - timedelta(hours=4),
                        'end': event_time - timedelta(hours=1)
                    },
                    'exit_target': event_time + timedelta(hours=2)
                })

                # Post-event opportunity (if we have data)
                if event.has_data:
                    opportunities.append({
                        'type': 'volatility_post_event',
                        'event': event,
                        'action': 'SELL_VOLATILITY',
                        'rationale': f"Sell volatility decay after {event.event} data release",
                        'entry_window': {
                            'start': event_time + timedelta(minutes=5),
                            'end': event_time + timedelta(hours=1)
                        }
                    })

        return opportunities

    async def get_risk_zones(self, hours_ahead: int = 48) -> List[Dict[str, Any]]:
        """
        Define risk zones where trading should be avoided or position sizes reduced.
        """
        risk_zones = []
        now = datetime.now()

        for event in self.high_impact_events:
            event_time = event.event_datetime
            time_until = (event_time - now).total_seconds() / 3600

            if 0 < time_until <= hours_ahead:
                # Define risk zones around event
                high_risk_start = event_time - timedelta(hours=2)
                high_risk_end = event_time + timedelta(hours=1)
                extreme_risk_start = event_time - timedelta(minutes=30)
                extreme_risk_end = event_time + timedelta(minutes=30)

                risk_zones.append({
                    'event': event,
                    'high_risk_zone': {
                        'start': high_risk_start,
                        'end': high_risk_end,
                        'risk_level': 'HIGH',
                        'recommended_action': 'Reduce position sizes by 50%'
                    },
                    'extreme_risk_zone': {
                        'start': extreme_risk_start,
                        'end': extreme_risk_end,
                        'risk_level': 'EXTREME',
                        'recommended_action': 'Avoid new positions, consider exiting existing'
                    }
                })

        return risk_zones

    async def get_surprise_trading_opportunities(self) -> List[Dict[str, Any]]:
        """
        Identify opportunities to trade economic surprises (actual vs forecast).
        """
        opportunities = []

        for event in self.high_impact_events:
            if event.has_data and event.forecast and event.actual:
                try:
                    # Parse values (simplified - would need better parsing)
                    forecast_val = self._parse_value(event.forecast)
                    actual_val = self._parse_value(event.actual)

                    if forecast_val and actual_val:
                        surprise = actual_val - forecast_val
                        surprise_pct = abs(surprise / forecast_val) if forecast_val != 0 else 0

                        if surprise_pct > 0.01:  # >1% surprise
                            opportunities.append({
                                'event': event,
                                'surprise': surprise,
                                'surprise_pct': surprise_pct,
                                'direction': 'POSITIVE' if surprise > 0 else 'NEGATIVE',
                                'magnitude': 'LARGE' if surprise_pct > 0.05 else 'MODERATE',
                                'trading_opportunity': self._analyze_surprise_impact(event, surprise),
                                'confidence': min(surprise_pct * 100, 90)  # Higher surprise = higher confidence
                            })

                except Exception as e:
                    logger.warning(f"Error analyzing surprise for {event.event}: {e}")

        return opportunities

    async def get_market_context(self) -> Dict[str, Any]:
        """
        Provide overall market context based on upcoming economic events.
        """
        now = datetime.now()
        week_ahead = now + timedelta(days=7)

        upcoming_high_impact = [
            event for event in self.high_impact_events
            if event.is_high_impact and now <= event.event_datetime <= week_ahead
        ]

        # Analyze by country
        country_impact = {}
        for event in upcoming_high_impact:
            country = event.country
            if country not in country_impact:
                country_impact[country] = []
            country_impact[country].append(event)

        # Determine volatility regime
        high_impact_count = len(upcoming_high_impact)
        if high_impact_count >= 5:
            volatility_regime = "EXTREME"
            context = "Heavy economic calendar this week. Expect significant volatility and risk-off moves."
        elif high_impact_count >= 3:
            volatility_regime = "HIGH"
            context = "Several important economic events. Monitor for volatility spikes."
        elif high_impact_count >= 1:
            volatility_regime = "MODERATE"
            context = "Some economic events may cause brief volatility."
        else:
            volatility_regime = "LOW"
            context = "Light economic calendar. Relatively stable conditions expected."

        return {
            'volatility_regime': volatility_regime,
            'context': context,
            'total_upcoming_events': len(upcoming_high_impact),
            'high_impact_events': high_impact_count,
            'countries_affected': list(country_impact.keys()),
            'key_events': [
                {
                    'country': event.country,
                    'event': event.event,
                    'datetime': event.event_datetime.isoformat(),
                    'importance': event.importance
                }
                for event in upcoming_high_impact[:5]
            ]
        }

    def _calculate_confidence(self, event: EconomicEvent) -> float:
        """Calculate confidence score for trading opportunity"""
        confidence = 50.0  # Base confidence

        # Higher for US events (most market impact)
        if event.country == "United States":
            confidence += 20

        # Higher for rate decisions
        if "interest rate" in event.event.lower() or "fed" in event.event.lower():
            confidence += 15

        # Higher for employment data
        if "payroll" in event.event.lower() or "employment" in event.event.lower():
            confidence += 15

        # Lower for speeches (less predictable)
        if "speech" in event.event.lower() or "press conference" in event.event.lower():
            confidence -= 10

        return min(confidence, 95.0)

    def _parse_value(self, value_str: str) -> Optional[float]:
        """Parse economic value strings to float"""
        if not value_str:
            return None

        try:
            # Remove common suffixes and clean
            cleaned = value_str.replace('%', '').replace(',', '').replace('$', '').strip()
            return float(cleaned)
        except:
            return None

    def _analyze_surprise_impact(self, event: EconomicEvent, surprise: float) -> Dict[str, Any]:
        """Analyze the market impact of an economic surprise"""
        event_lower = event.event.lower()
        country = event.country

        # US Economic surprises have strongest impact
        if country == "United States":
            if "unemployment" in event_lower and surprise < 0:  # Better than expected
                return {
                    'action': 'BUY',
                    'asset': 'SPY',
                    'timeframe': 'IMMEDIATE',
                    'rationale': 'US employment better than expected = bullish for equities'
                }
            elif "fed" in event_lower and "rate" in event_lower:
                if surprise > 0:  # More hawkish than expected
                    return {
                        'action': 'SELL',
                        'asset': 'SPY',
                        'timeframe': 'IMMEDIATE',
                        'rationale': 'Fed more hawkish = bearish for equities'
                    }
            elif "payroll" in event_lower and surprise > 0:  # Better than expected
                return {
                    'action': 'BUY',
                    'asset': 'SPY',
                    'timeframe': 'INTRADAY',
                    'rationale': 'Strong employment data = bullish'
                }

        # Generic surprise response
        if abs(surprise) > 1.0:
            return {
                'action': 'MONITOR_VOLATILITY',
                'asset': 'VIX',
                'timeframe': 'IMMEDIATE',
                'rationale': 'Significant economic surprise = volatility opportunity'
            }

        return {
            'action': 'MONITOR',
            'asset': 'MARKET',
            'timeframe': 'SHORT_TERM',
            'rationale': 'Economic surprise may influence market direction'
        }


async def main():
    """Test the exploitation engine"""
    print("üî• TRADING ECONOMICS EXPLOITATION ENGINE TEST")
    print("=" * 60)

    exploiter = EconomicCalendarExploiter()

    # Test volatility opportunities
    print("\n1Ô∏è‚É£ VOLATILITY TRADING OPPORTUNITIES")
    vol_ops = await exploiter.get_volatility_opportunities(48 * 365 * 24)  # Include all events
    print(f"Found {len(vol_ops)} volatility opportunities:")
    for i, op in enumerate(vol_ops[:3]):
        event = op['event']
        time_until = op.get('time_until_hours', 'N/A')
        print(f"  {i+1}. {event.event} - {op['action']} ({time_until}h)")

    # Test risk zones
    print("\n2Ô∏è‚É£ RISK MANAGEMENT ZONES")
    risk_zones = await exploiter.get_risk_zones(48)
    print(f"Found {len(risk_zones)} risk zones:")
    for i, zone in enumerate(risk_zones[:2]):
        event = zone['event']
        print(f"  {i+1}. {event.event} - HIGH RISK: {zone['high_risk_zone']['recommended_action']}")

    # Test surprise opportunities
    print("\n3Ô∏è‚É£ ECONOMIC SURPRISE OPPORTUNITIES")
    surprise_ops = await exploiter.get_surprise_trading_opportunities()
    print(f"Found {len(surprise_ops)} surprise opportunities:")
    for i, op in enumerate(surprise_ops[:2]):
        event = op['event']
        print(f"  {i+1}. {event.event}: {op['surprise_pct']:.1%} surprise - {op['trading_opportunity']['action']} {op['trading_opportunity']['asset']}")

    # Test market context
    print("\n4Ô∏è‚É£ MARKET CONTEXT")
    context = await exploiter.get_market_context()
    print(f"Volatility Regime: {context['volatility_regime']}")
    print(f"Context: {context['context']}")
    print(f"High-impact events this week: {context['high_impact_events']}")

    print("\n" + "=" * 60)
    print("‚úÖ EXPLOITATION ENGINE TEST COMPLETE")


if __name__ == "__main__":
    asyncio.run(main())
